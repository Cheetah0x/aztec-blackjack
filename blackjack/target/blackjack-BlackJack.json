{"transpiled":true,"noir_version":"0.36.0+b0cbf84eaf69f77628939184c9b869cfb3e15846-aarch64","name":"BlackJack","functions":[{"name":"constructor","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"error_types":{},"parameters":[{"name":"inputs","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs"},"visibility":"private"},{"name":"player","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"fields":[{"name":"_opt","type":{"fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::option::Option"}}],"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber"}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest"}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"fields":[{"name":"request","type":{"fields":[{"name":"pk_m","type":{"fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}],"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint"}},{"name":"sk_app","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest"}},{"name":"sk_app_generator","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator"}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash"}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier"}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest"}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}}},{"name":"public_teardown_call_request","type":{"fields":[{"name":"call_context","type":{"fields":[{"name":"msg_sender","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"function_selector","type":{"fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector"}},{"name":"is_static_call","type":{"kind":"boolean"}}],"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest"}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"fields":[{"name":"recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message"}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash"}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash"}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash"}}},{"name":"historical_header","type":{"fields":[{"name":"last_archive","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"content_commitment","type":{"fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment"}},{"name":"state","type":{"fields":[{"name":"l1_to_l2_message_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"partial","type":{"fields":[{"name":"note_hash_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"nullifier_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}},{"name":"public_data_tree","type":{"fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot"}}],"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference"}}],"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference"}},{"name":"global_variables","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress"}},{"name":"fee_recipient","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}},{"name":"gas_fees","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}}],"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables"}},{"name":"total_fees","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::header::Header"}},{"name":"tx_context","type":{"fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"fields":[{"name":"gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"teardown_gas_limits","type":{"fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas"}},{"name":"max_fees_per_gas","type":{"fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees"}},{"name":"inclusion_fee","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings"}}],"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext"}}],"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs"},"visibility":"databus"}},"bytecode":"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","debug_symbols":"7V3Rbts6DP2XPPdBpCiJ6q9cXAxp1w0BgnRouwtcFP33KV4lK7UTNYiTqLT2MNQto/CcY8uHtGW/Lr4/3P3++W21+fH4vLj953WxfrxfvqweN2HrdQG6+93zr+Vmu/n8snx6WdyC9epm8bD5Hn50Sr3dLH6s1g+LW2febgbByJreg5GNTcFg1Ui0NmDeo7VhLkRD+BcHDz9iH68Rx+KZbQz3yvTRNDo4+jS24zz435sFUGNmDzOmMbOHGduY2cOMO5kZUhixkrKQgj13X8Dn/gJ/urZoIp+InGlr/Ei0oxjsuOceNG6zQXXpbKDPxu5kMzKyQowjE/VpaBiLJnCJdvA22ydVhxRmgxRng1TPBinNBqmZDVI7G6RuNkh5Nkj9XJBqQR6JVEyaCGGAVJBHKiAV5JEKSAV5pAJSmg1SQR6pgFSQRyogFeSRCkgFeaQCUkEe6TBSEuSRbN++szRwgyTIIxWQCvJIBaSCPFIBKc0GqSCPVEAqyCMVkArySAWkgjxSAakgj3QYqRHkkZjiRVpiN3CDRpBHKiAV5JEKSAV5pAJSmg1SQR6pgFSQRyogFeSRCkgFeaQCUkEe6TBSe2mP5NnFkZUqQnWK49CcDT0OFRDTXXLoKYu2I9HWxEQ4v0UOxiCCsjrdUacs+YzG0UwoSQREGenH34BnoQlUt0DYBKpbIN0E+pRATvcCsSsJNN09xpaaQHULZAQJBL1Aeof0MYHA9NOQ9VCKvqJEtklUu0Suaoks6SSRdwWJ0KeZC73TWbQeidYAUX4dSpadGqQuq8BNotol8k2iyiVydfcUmkRBorq7Ck2iIFHdfYUmUZCo7s5CkyhIRE2i2iWqu7vQJAoS1d1daBIFiVp3oXqJWneheolad6F2ibh1F6qXqHUXqpeodRc+K9G1rhdx6y5ULxHJkUgrFa+6hkunpiDRNUkX1C/4OqQL6gBoTE9T1Gi4QHqYgCIvSBnlSEXG+3kOTUeioBr9nCR6YxKJ2Z6Iow9/tBEi+Yxv2/EtqOA+I9+oFMRghXQC34Kq53PyDZASAe0/TBJeUH17ThJDdI9RH95pQfcYKTsRvjMuqFz9IowLqj6rYdzo5A1N9gDqo2dxL6julCcONXGmFyc9jjJwcILf9JIqU3HiSKpgwdteHF8QJ7SKY9uYKGunjYqjXeJQM+g8eEuipAr2jCSyjxWV9kMSJZWlVyNRUq15LRIDksbiBCxKKiCvx6KkovB6LEqq3q7HIjUWJ2BRUj10PRZb4TIFi1IrF1u6myJMZgmjyp4ANMqiAR9rcxM6AAMWpZYul2VRau1yURZBau1yWRal1i4Ts4jprY4GrR2wKLV2uSyLUmuXy7JIjcUJWJRau0zMonXRdRsHBYvu+tvdneWBRQephU7FlLeq6FOUMyTK2eBplLcS6gyU+4jROYAB5a3eujTldb/nHPrVKCGPHca75Kt+nUIp+XYZ5XPtwpSIZuMG+2+7jDIFi3RFFsHtsNjlM4Gp14keDOgL+WB/N00QSheir7i+B6Z4ObpUaiYwyTqdLZEId8B2XzGBKTRpKRka9AU+jfMmnetB7cwJXUK+soSmeCn4tAlNYBJMqhTQOFc6BEBneykNE8LaEtK1JUS1JWSm2Kl1nxAPZpYJXujMEEFw9tCBPUdNP++afAHk9s7dkXO7wv7krozJw7vk3VdNPmzcPa3W69XPb+vH++XL6nHzvP2w2v433nUx6anXxsLAuvDxH/FHf2S8ajv8ETj+I3jkR8IWdLyNz3Aqla2g9M5So5FKK50CHGAe2u1u5x2eTh8+rSJx9HHd4J6G9XHDY2pcfVy7vKc5O9nw7vThOR7pLiuJ3ofn8w7vTx6e02TC9HHP2dNMOW74aGZ4d/nR3kP4uOFdlJYH5CBOOLz/cFiFDTwwNYBKD8wBxZ87YoDSghOwhaVarEw8FbFyu0tO3sLWf8un1fJu/bCd+7d//L25j6eCsPny/6+/fwnBfwA=","brillig_names":["get_contract_instance_internal","decompose_hint","lte_hint","directive_integer_quotient","directive_invert"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"begin_game","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[{"name":"player","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["begin_game"],"assert_messages":{"1926":"Array index out of bounds","1859":"attempt to add with overflow","1146":"attempt to add with overflow","3962":"Array index out of bounds","4084":"attempt to add with overflow","433":"attempt to multiply with overflow","1134":"Array index out of bounds","2091":"Array index out of bounds","744":"Array index out of bounds","488":"Array index out of bounds","1512":"Array index out of bounds","2914":"Array index out of bounds","3548":"attempt to add with overflow","2457":"attempt to add with overflow","4127":"Array index out of bounds","787":"Array index out of bounds","464":"attempt to add with overflow","1677":"Array index out of bounds","2378":"Array index out of bounds","3079":"Array index out of bounds","4103":"Array index out of bounds","2689":"Array index out of bounds","2622":"attempt to add with overflow","3902":"Array index out of bounds","4115":"attempt to add with overflow","2421":"Array index out of bounds","2854":"Array index out of bounds","483":"attempt to multiply with overflow","995":"attempt to add with overflow","1117":"attempt to add with overflow","3677":"Array index out of bounds","471":"push out of bounds","4067":"Array index out of bounds","849":"Array index out of bounds","782":"attempt to add with overflow","1550":"Array index out of bounds","1806":"attempt to add with overflow","3842":"Array index out of bounds","2940":"attempt to add with overflow","3452":"Array index out of bounds","502":"Array index out of bounds","1459":"Array index out of bounds","3117":"attempt to add with overflow","234":"attempt to add with overflow","679":"Storage slot 0 not allowed. Storage slots must start from 1.","2983":"Array index out of bounds","3105":"attempt to add with overflow","3617":"Array index out of bounds","3940":"Array index out of bounds","4139":"attempt to add with overflow","1935":"Array index out of bounds","844":"attempt to multiply with overflow","2569":"attempt to add with overflow","1478":"attempt to add with overflow","1399":"Array index out of bounds","2100":"Array index out of bounds","497":"attempt to add with overflow","753":"attempt to add with overflow","1643":"attempt to add with overflow","552":"Array index out of bounds","1064":"Array index out of bounds","1442":"Array index out of bounds","1710":"Array index out of bounds","28":"Not initialized","2923":"Array index out of bounds","3703":"attempt to add with overflow","1875":"Array index out of bounds","3088":"Array index out of bounds","3746":"Array index out of bounds","2698":"Array index out of bounds","3868":"attempt to add with overflow","4033":"attempt to add with overflow","760":"Attempted to read past end of BoundedVec","2863":"Array index out of bounds","3375":"attempt to add with overflow","1961":"attempt to add with overflow","2473":"Array index out of bounds","547":"attempt to add with overflow","3686":"Array index out of bounds","2138":"attempt to add with overflow","535":"Array index out of bounds","2004":"Array index out of bounds","2961":"Array index out of bounds","2126":"attempt to add with overflow","2638":"Array index out of bounds","3851":"Array index out of bounds","901":"Array index out of bounds","3461":"Array index out of bounds","511":"attempt to add with overflow","1590":"attempt to add with overflow","3626":"Array index out of bounds","420":"push out of bounds","2724":"attempt to add with overflow","1944":"Array index out of bounds","530":"attempt to multiply with overflow","2767":"Array index out of bounds","3724":"Array index out of bounds","2889":"attempt to add with overflow","774":"Array index out of bounds","518":"push out of bounds","3980":"attempt to add with overflow","2109":"Array index out of bounds","1719":"Array index out of bounds","884":"attempt to add with overflow","561":"attempt to add with overflow","1073":"Array index out of bounds","3054":"attempt to add with overflow","872":"Array index out of bounds","3365":"attempt to bit-shift with overflow","3487":"attempt to add with overflow","1884":"Array index out of bounds","2396":"attempt to add with overflow","1494":"Array index out of bounds","2707":"Array index out of bounds","3408":"attempt to bit-shift with overflow","3530":"Array index out of bounds","1159":"attempt to add with overflow","3652":"attempt to add with overflow","769":"attempt to multiply with overflow","1982":"Array index out of bounds","379":"attempt to add with overflow","1659":"Array index out of bounds","2872":"Array index out of bounds","2482":"Array index out of bounds","3884":"Array index out of bounds","3817":"attempt to add with overflow","2647":"Array index out of bounds","977":"Array index out of bounds","910":"Array index out of bounds","1099":"attempt to add with overflow","1745":"attempt to add with overflow","3470":"Array index out of bounds","4049":"Array index out of bounds","1788":"Array index out of bounds","2745":"Array index out of bounds","1910":"attempt to add with overflow","307":"attempt to add with overflow","819":"Array index out of bounds","3001":"attempt to add with overflow","3635":"Array index out of bounds","4092":"Array index out of bounds","4147":"Stack too deep","862":"Array index out of bounds","2075":"attempt to add with overflow","405":"attempt to add with overflow","2386":"attempt to bit-shift with overflow","2508":"attempt to add with overflow","1417":"attempt to add with overflow","1728":"Array index out of bounds","2429":"attempt to bit-shift with overflow","1082":"Array index out of bounds","2551":"Array index out of bounds","3508":"Array index out of bounds","2673":"attempt to add with overflow","3764":"attempt to add with overflow","936":"attempt to add with overflow","1125":"Array index out of bounds","1893":"Array index out of bounds","1503":"Array index out of bounds","857":"attempt to add with overflow","2838":"attempt to add with overflow","2905":"Array index out of bounds","3417":"Array index out of bounds","333":"attempt to add with overflow","455":"Array index out of bounds","1668":"Array index out of bounds","3070":"Array index out of bounds","955":"Array index out of bounds","2491":"Array index out of bounds","3893":"Array index out of bounds","3436":"attempt to add with overflow","809":"attempt to add with overflow","1766":"Array index out of bounds","2022":"attempt to add with overflow","2656":"Array index out of bounds","797":"Array index out of bounds","3357":"Array index out of bounds","919":"Array index out of bounds","1108":"Array index out of bounds","3601":"attempt to add with overflow","3668":"Array index out of bounds","4058":"Array index out of bounds","3400":"Array index out of bounds","261":"attempt to add with overflow","450":"attempt to add with overflow","1407":"attempt to bit-shift with overflow","828":"attempt to add with overflow","1529":"attempt to add with overflow","438":"Array index out of bounds","3833":"Array index out of bounds","1450":"attempt to bit-shift with overflow","1572":"Array index out of bounds","2529":"Array index out of bounds","1694":"attempt to add with overflow","2785":"attempt to add with overflow","1048":"attempt to add with overflow","3919":"attempt to add with overflow","2438":"Array index out of bounds","835":"Attempted to read past end of BoundedVec"}},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"5443":"attempt to add with overflow","4742":"Array index out of bounds","2938":"Array index out of bounds","4419":"Array index out of bounds","299":"attempt to add with overflow","1512":"attempt to add with overflow","3371":"Array index out of bounds","4584":"Array index out of bounds","5206":"Array index out of bounds","1299":"attempt to add with overflow","2323":"attempt to add with overflow","5261":"Array index out of bounds","330":"Not initialized","3457":"attempt to add with overflow","3969":"Array index out of bounds","4993":"Array index out of bounds","1976":"Array index out of bounds","4914":"attempt to multiply with overflow","4457":"Array index out of bounds","3622":"attempt to add with overflow","4134":"Array index out of bounds","4835":"attempt to add with overflow","4701":"Array index out of bounds","1361":"attempt to multiply with overflow","3086":"attempt to add with overflow","4945":"attempt to add with overflow","4220":"attempt to add with overflow","2227":"Array index out of bounds","3440":"Array index out of bounds","1581":"Array index out of bounds","4976":"attempt to add with overflow","935":"Array index out of bounds","1959":"Array index out of bounds","4385":"attempt to add with overflow","5165":"Array index out of bounds","2392":"Array index out of bounds","3605":"Array index out of bounds","4550":"attempt to add with overflow","887":"attempt to add with overflow","2478":"attempt to add with overflow","2990":"Array index out of bounds","4203":"Array index out of bounds","918":"Array index out of bounds","2643":"attempt to add with overflow","3155":"Array index out of bounds","461":"Function view_deck can only be called statically","3478":"Array index out of bounds","4368":"Array index out of bounds","5069":"Array index out of bounds","2107":"attempt to add with overflow","4667":"attempt to add with overflow","4722":"attempt to add with overflow","815":"attempt to add with overflow","5234":"Attempted to read past end of BoundedVec","3241":"attempt to add with overflow","2461":"Array index out of bounds","4241":"Array index out of bounds","3406":"attempt to add with overflow","4808":"attempt to add with overflow","901":"push out of bounds","2626":"Array index out of bounds","3571":"attempt to add with overflow","1389":"Array index out of bounds","743":"attempt to add with overflow","4004":"attempt to add with overflow","5028":"attempt to add with overflow","2011":"Array index out of bounds","3224":"Array index out of bounds","3925":"attempt to bit-shift with overflow","4169":"attempt to add with overflow","1286":"attempt to multiply with overflow","2499":"Array index out of bounds","2176":"Array index out of bounds","963":"attempt to multiply with overflow","3389":"Array index out of bounds","5248":"Array index out of bounds","4334":"attempt to add with overflow","2262":"attempt to add with overflow","403":"Storage slot 0 not allowed. Storage slots must start from 1.","1427":"Array index out of bounds","1616":"attempt to add with overflow","3987":"Array index out of bounds","5011":"Array index out of bounds","4609":"Array index out of bounds","3262":"Array index out of bounds","2427":"attempt to add with overflow","4152":"Array index out of bounds","1379":"Array index out of bounds","2592":"attempt to add with overflow","977":"attempt to add with overflow","3025":"attempt to add with overflow","5451":"Array index out of bounds","1032":"Array index out of bounds","2245":"Array index out of bounds","2946":"attempt to bit-shift with overflow","1599":"Array index out of bounds","4025":"Array index out of bounds","3190":"attempt to add with overflow","173":"Not initialized","2410":"Array index out of bounds","5214":"Array index out of bounds","3355":"attempt to add with overflow","4891":"attempt to add with overflow","716":"attempt to add with overflow","5379":"attempt to add with overflow","1472":"Array index out of bounds","3008":"Array index out of bounds","4410":"Array index out of bounds","1015":"Array index out of bounds","5434":"Array index out of bounds","3953":"attempt to add with overflow","2283":"Array index out of bounds","4843":"Array index out of bounds","3173":"Array index out of bounds","1314":"Array index out of bounds","991":"attempt to add with overflow","3874":"Array index out of bounds","4575":"Array index out of bounds","4118":"attempt to add with overflow","4953":"attempt to add with overflow","5087":"attempt to add with overflow","4874":"attempt to add with overflow","1345":"attempt to add with overflow","2046":"attempt to add with overflow","4795":"attempt to multiply with overflow","5362":"attempt to multiply with overflow","1967":"attempt to bit-shift with overflow","998":"push out of bounds","2211":"attempt to add with overflow","3046":"Array index out of bounds","1565":"attempt to add with overflow","5283":"attempt to add with overflow","5472":"attempt to add with overflow","4692":"attempt to add with overflow","5393":"attempt to add with overflow","1352":"Attempted to read past end of BoundedVec","2376":"attempt to add with overflow","4936":"Array index out of bounds","4479":"Array index out of bounds","1651":"Array index out of bounds","5424":"attempt to add with overflow","2029":"Array index out of bounds","4778":"attempt to add with overflow","3431":"Array index out of bounds","4644":"Array index out of bounds","5156":"Array index out of bounds","2974":"attempt to add with overflow","1304":"Array index out of bounds","4754":"attempt to add with overflow","2194":"Array index out of bounds","4620":"Array index out of bounds","335":"Function player_hand can only be called statically","2895":"Array index out of bounds","3596":"Array index out of bounds","3139":"attempt to add with overflow","4919":"Array index out of bounds","1634":"attempt to add with overflow","4194":"Array index out of bounds","1366":"Array index out of bounds","2067":"Array index out of bounds","74":"Not initialized","4359":"Array index out of bounds","3634":"attempt to add with overflow","3500":"Array index out of bounds","4902":"push out of bounds","861":"attempt to add with overflow","4823":"Array index out of bounds","2452":"Array index out of bounds","5201":"attempt to add with overflow","1995":"attempt to add with overflow","5256":"attempt to add with overflow","1916":"Array index out of bounds","2617":"Array index out of bounds","1270":"attempt to add with overflow","2160":"attempt to add with overflow","4263":"Array index out of bounds","4964":"Array index out of bounds","789":"attempt to add with overflow","3215":"Array index out of bounds","4672":"Array index out of bounds","1277":"Attempted to read past end of BoundedVec","3380":"Array index out of bounds","3892":"attempt to add with overflow","930":"attempt to add with overflow","2655":"attempt to add with overflow","2521":"Array index out of bounds","4813":"Array index out of bounds","1418":"Array index out of bounds","3978":"Array index out of bounds","5002":"Array index out of bounds","5191":"attempt to add with overflow","4143":"Array index out of bounds","4710":"Array index out of bounds","3284":"Array index out of bounds","913":"attempt to multiply with overflow","4497":"attempt to add with overflow","1291":"Array index out of bounds","456":"Not initialized","968":"Array index out of bounds","2236":"Array index out of bounds","1401":"attempt to add with overflow","1590":"Array index out of bounds","5174":"Array index out of bounds","944":"attempt to add with overflow","3882":"attempt to bit-shift with overflow","2401":"Array index out of bounds","2913":"attempt to add with overflow","5339":"attempt to add with overflow","4047":"Array index out of bounds","1676":"attempt to add with overflow","951":"push out of bounds","2999":"Array index out of bounds","4401":"Array index out of bounds","5047":"Array index out of bounds","5291":"Array index out of bounds","5480":"Stack too deep","3164":"Array index out of bounds","5401":"attempt to add with overflow","982":"Array index out of bounds","1494":"Array index out of bounds","4566":"Array index out of bounds","5322":"attempt to add with overflow","2305":"Array index out of bounds","3518":"attempt to add with overflow","4731":"Array index out of bounds","1336":"Array index out of bounds","5243":"attempt to multiply with overflow","178":"Function dealer_hand can only be called statically","4786":"Attempted to read past end of BoundedVec","2903":"attempt to bit-shift with overflow","5140":"attempt to add with overflow","1934":"attempt to add with overflow","5384":"Array index out of bounds","3068":"Array index out of bounds","4281":"attempt to add with overflow","1453":"attempt to add with overflow","1642":"Array index out of bounds","5226":"attempt to add with overflow","2020":"Array index out of bounds","1374":"attempt to add with overflow","3422":"Array index out of bounds","3934":"Array index out of bounds","2185":"Array index out of bounds","1027":"attempt to add with overflow","4800":"Array index out of bounds","3587":"Array index out of bounds","570":"attempt to add with overflow","5367":"Array index out of bounds","1326":"attempt to add with overflow","2539":"attempt to add with overflow","1436":"Array index out of bounds","601":"Not initialized","1625":"Array index out of bounds","4185":"Array index out of bounds","3917":"Array index out of bounds","1924":"attempt to bit-shift with overflow","4350":"Array index out of bounds","1144":"Storage slot 0 not allowed. Storage slots must start from 1.","1010":"attempt to multiply with overflow","2089":"Array index out of bounds","3302":"attempt to add with overflow","5350":"push out of bounds","5271":"Array index out of bounds","4436":"attempt to add with overflow","1041":"attempt to add with overflow","5460":"Array index out of bounds","2443":"Array index out of bounds","2955":"Array index out of bounds","4680":"Array index out of bounds","1663":"attempt to add with overflow","4601":"attempt to add with overflow","2608":"Array index out of bounds","1261":"Array index out of bounds","4656":"attempt to add with overflow","5412":"Array index out of bounds","4065":"attempt to add with overflow","4766":"Array index out of bounds","4632":"attempt to add with overflow","3206":"Array index out of bounds","4931":"attempt to add with overflow"}},{"name":"player_hand","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[{"name":"player","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":{"abi_type":{"fields":[{"name":"cards","type":{"fields":[{"name":"storage","type":{"kind":"array","length":6,"type":{"fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}],"kind":"struct","path":"CardNote::CardNote::Card"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"}},{"name":"bust","type":{"kind":"boolean"}}],"kind":"struct","path":"CardNote::CardNote::Hand"},"visibility":"public"}},"bytecode":"JgAEAQInAASAUgABJgAEAwAmAgQBAiYCBAADHxgAAwACgEMtCIBDAAEkAAAAEgAoAQIEJwIEgEQABSYCBAwGLQQABIADLQQABYAELQQABoAFJAAAAkEtBAACgFAtBAADgFE6AIBEAA4kAAACTCwIAQMAAAECASYCAQAELA4EAywIAQMAAAECASYCAAAFLA4FAywIAQMAAAECASYCAAIGLA4GAx4CAAADHgIAAAYyOAADAAYAByYCAQEDIwIAAAAmAAcmAgQABjsJAAYeAgoABiYCAAEHCjgGBwgjAgAAACwACCYCBAAJOwkACSwIAQYmAgQEBwAQAQcBJgMEAQYAKAYCBywMBwgsDgUIACgIAggsDgUIACgIAggsDgUILA0GBwAoBwIHLA4HBiwNBgcAKAcCBywOBwYsDQYHACgHAgcsDgcGLA0GBwAoBwIHLA4HBiwIAQcAAAECASwOBgcsCAEGJgIEBQgAEAEIASYDBAEGACgGAggsDAgJLA4FCQAoCQIJLA4FCQAoCQIJLA4FCQAoCQIJKgIAAAAAAAAAAAIAAAAAAAAAAAAKLA4KCSwNBggAKAgCCCwOCAYsCAEIAAABAgEsDgYILAgBBgAAAQIBJgIEAAksDgkGLAgBCgAAAQIBLA4ECiYCBAILJgIEAQwmAgQEDSYCAAoOJgIEAw8sDAkCIgAAAGgMOAILECMCAAABngAQIgAAAGssDQoCCjgCBA4jAgAAAHAADiYCBAAQOwkAECwMCQEiAAAAcgw4AQ8CIwIAAAFrAAIiAAAAdSwNBwIsDQYOLA0IECwIAREmAgQFEgAQARIBJgMEAREAKBACEiYCBAQTACgRAhQ+DwASABQsDQINAigNAg0sDg0CLA4CBywOEQgsDg4GLA4DCgAoEQIGADgGCQcsDQcCCjgCBQYKOAYEByMCAAAAjwAHJgIEAAg7CQAILAgBBiYCBAcHABABBwEmAwQBBgAoBgIHLAwHCCwOBQgAKAgCCCwOBQgAKAgCCCwOBQgAKAgCCCwOBQgAKAgCCCwOBQgAKAgCCCwOBQgsDQYHACgHAgcsDgcGLAgBBwAAAQIBLA4GByYCBAYGLAwJASIAAACpDDgBBggjAgAAAVMACCIAAACsLA0HAiwIAQcmAgQNCAAQAQgBJgMEAQcAKAcCCCwMCAosDgUKACgKAgosDgUKACgKAgosDgUKACgKAgosDgUKACgKAgosDgUKACgKAgosDgUKACgKAgosDgUKACgKAgosDgUKACgKAgosDgUKACgKAgosDgUKACgKAgosDgUKACgKAgosDgUKLA0HCAAoCAIILA4IBywIAQgAAAECASwOBwgsCAEHAAABAgEsDgkHJwIEAQAACiYCBA4NLAwJASIAAADXDDgBBg4jAgAAAN4ADiIAAADaLA0IASwNBwIsDAQDJSYCBAYQDDgBEBEjAgAAAOMAESYCBAASOwkAEgAoAgIQADgQAREsDREOCjgOBRAWDBARIwIAAADqABEiAAABTCwIARAmAgQhEQAQAREBJgMEARAAKBACEUM6AA4AEQAKACAAJgIEIBItBAARgAMtBAASgAQkAAACUgAoEAIRADgRCRIsDRIOHAwEDhEAKBACEgA4EgwTLA0TDhwMBA4SBDgSCg4AOBEOEg44ERITIwIAAAECABMmAgQAFDsJABQGOBINEQQ4EQ0TAjgSEw4AKBACEgA4EgsTLA0TERwMBBESACgQAhMAOBMPFCwNFBEcDAQREAQ4EAoRADgSERAOOBIQEyMCAAABEwATJgIEABQ7CQAUJgIEBBIGOBASEwQ4ExIUAjgQFBEcDAAOEBwMABEOLA0HEQw4EQYSIwIAAAEeABImAgQAETsJABEsDQgRLA0HEiwNBxMEOBMLFCYCBAAWCjgWCxUjAgAAASoAFQY4FAsYCjgYExcjAgAAASoAFyYCBAAZOwkAGSYCBAwVDDgUFRYjAgAAAS8AFiYCBAAXOwkAFy0EABGAAycABAANgAQkAAACZS0IgAUAEwAoEwIVADgVFBYsDhAWADgUDBAOOBQQESMCAAABOwARJgIEABU7CQAVJgIEDBQMOBAUFSMCAAABQAAVJgIEABY7CQAWACgTAhQAOBQQFSwODhUsDBMRADgSDA4OOBIOECMCAAABSQAQJgIEABM7CQATLA4RCCwODgciAAABTAA4AQwODjgBDhAjAgAAAVEAECYCBAAROwkAESwMDgEiAAAA1ywNBwgcDAABCgA4AgoNLgwADQAKJgIEBg4MOAEOECMCAAABXAAQJgIEABE7CQARLQQACIADJwAEAAeABCQAAAJlLQiABQANACgNAg4AOA4BECwOChAAOAEMCA44AQgKIwIAAAFoAAomAgQADjsJAA4sDg0HLAwIASIAAACpLA0GAgw4AQIOIwIAAAFvAA4iAAABlywNBwIsDQgOLA0GECwNChEsDQgSJgIEBBQMOAEUFSMCAAABeQAVJgIEABY7CQAWACgSAhQAOBQBFSwNFRMsDQcSJgIEAxUMOAEVFiMCAAABggAWJgIEABc7CQAXACgSAhUAOBUBFiwNFhQAOBMUEiYCBAQUDDgBFBUjAgAAAYsAFSYCBAAWOwkAFi0EAA6AAycABAAFgAQkAAACZS0IgAUAEwAoEwIUADgUARUsDhIVLA4CBywOEwgsDhAGLA4RCiIAAAGXADgBDAIOOAECDiMCAAABnAAOJgIEABA7CQAQLAwCASIAAAByDDgCCxAjAgAAAaEAECIAAAIHLAgBECYCBAMRABABEQEmAwQBEAAoEAIRLAwREiwODhIAKBICEiwOARImAgQCEgw4AhITIwIAAAGvABMmAgQAFDsJABQAKBACEgA4EgITLA0TESwNChAKOBAEEiMCAAABtwASJgIEABM7CQATLA0GEAo4EA8SIwIAAAHcABIiAAABuywNBxAsDQgSLA0GEywNChQsDQYVJgIEAxcMOBUXGCMCAAABxQAYJgIEABk7CQAZLQQAEIADJwAEAASABCQAAAJlLQiABQAWACgWAhcAOBcVGCwOERgsDRYQACgQAhAsDhAWLA0SEAAoEAIQLA4QEgA4EwwQDjgTEBEjAgAAAdcAESYCBAAVOwkAFSwOFgcsDhIILA4QBiwOFAoiAAACBywMCRAiAAAB3gw4EA8SIwIAAAIOABIiAAAB4SwNBxAsDQoSLA0IEywIARQmAgQFFQAQARUBJgMEARQAKBMCFSYCBAQWACgUAhc+DwAVABcsDRATAigTAhMsDhMQLA0QEwAoEwITLA4TECwNFBMAKBMCEywOExQtBAAQgAMnAAQABIAEJAAAAmUtCIAFABMAKBMCFQA4FQkWLA4RFiwNExAAKBACECwOEBMsDRQQACgQAhAsDhAULA4TBywOFAgsDgwGLA4SCiIAAAIHADgCDBAOOAIQESMCAAACDAARJgIEABI7CQASLAwQAiIAAABoLA0GEgw4EBITIwIAAAISABMiAAACOiwNBxIsDQgTLA0GFCwNChUsDQgWJgIEBBgMOBAYGSMCAAACHAAZJgIEABo7CQAaACgWAhgAOBgQGSwNGRcsDQcWJgIEAxkMOBAZGiMCAAACJQAaJgIEABs7CQAbACgWAhkAOBkQGiwNGhgAOBcYFiYCBAQYDDgQGBkjAgAAAi4AGSYCBAAaOwkAGi0EABOAAycABAAFgAQkAAACZS0IgAUAFwAoFwIYADgYEBksDhYZLA4SBywOFwgsDhQGLA4VCiIAAAI6ADgQDBIOOBASEyMCAAACPwATJgIEABQ7CQAULAwSECIAAAHeAQCAA4AFgActAIADgAgtAIAEgAkLAIAIgAeACiMAAAACS4AKLQGACIAGLQKABoAJAQCACAACgAgBAIAJAAKACSIAAAJEJScABHgAgAQNAAAAgASAAyMAAAACUYADJwAEAACABDwBAACABCUnAAQAAoAGBwCABIAGgAUtAIAEgAgnAAQAAIAJDQCACYAFgAoXAIAKgAojAAAAAmSACgMAgAgAAoAIAQCAA4AJgAstAYALgAYBAIADgAiACy0BgAuABwEAgAOACYALLQKAB4ALAQCAA4AIgAstAoAGgAsBAIAJAAKACSIAAAJWJS0BgAOABgsAgAYAAoAHIwAAAAJpgAciAAACay0AgAOABSIAAAJ5LQAAAYAFAQAAAYAEAAEBAIADgASACS0AgAOACi0AgAWACwsAgAqACYAMIwAAAAJ3gAwtAYAKgAgtAoAIgAsBAIAKAAKACgEAgAsAAoALIgAAAnAnAQQAAYAFIgAAAnklLQAYyhjK","debug_symbols":"7Z3dbhw3EoXfRde+4P+PX2WxCOzECQQYcmA7CywMv3tGYze7JdLsmWGrxCLPTSDFnNapTz2sc6hp8tvdHx/e//PXb/cPf376cvf2P9/uPn76/d3X+08Pp+++fX9z9/7z/ceP93/9tv3fd+LxPzKex3/5+93D47dfvr77/PXurXRRvLn78PDH6UsvxOkKf95//HD31tvv/31zp8QNr5E3vEbd8Bp9w2vMDa+xN7zG3fAaf8Nrwg2vueE+0DfcB/ra++BNPlgIuwwWyqbB0sbCaB30cunTlzGNjr4w2Gnjfg522qnt4Eft6gDtQS2DT+IJtesDtBuZuLs97lIFs4zWRtS1e6f8z8HeefFcuzlUuxRPtT/+BPviP8G9+E/wL/4TQvNPsFIud4WVeu+uUDEsd4VW8vldccOMZW6YscwNncvc0LnMDZ3LFN8ZSorl3aS2kH/xO9frbBo2v3OvS6PtMseozeylhSvP026dMKRY5y+tVGm2i8toozfXNoWhSovlNlLni9UGn2bDNC/67dBHgBYA2wA6AGwD6AGwDWAAwDaAEQCbAFoBgG0AJQC2AVQA2AZQA2AbQAOAbQCRRBoBIok0AkQSaQSIJHIBQL+sZzkvnwNEEmkD6JBEGgEiiTQCRBJpBIgk0gjQAOAzgI9UEC9KVJAZSlQQBEpU4O5LVGDZC1Q8fHiJCsx1iQocc4kKbHCJigGVAhV42xIVeNsSFXjbEhV42xIVeNsClQBvW6ICb1uiAm9bogJvW6JiQKVABd62RAXetkQF3rZEBd62RAXetkAlwtuWqMDblqjA25aowNuWqBhQKVCBty1RgbctUJFi2reQWbFYm2GZ1fMHFRcdweibB58ZzpoQrmEovdeLDB9lxnDWPHEgQzlr+jiS4axZ5UiGs7baqxiGsIiWUdj64GCWCwebtR+JFn4wbils2mVru1PVAhz9nhg4zAEtcAUncTRwma58mrBDBhy2gxj4rKuvrwZ81oXdVwNuAJwW+KzL0a8GfNaV7lcDjqRJDBxJkxg4kiYtcI2kSQwcSbMJ+JkhwmM7Q+TBdoYGDJsZIrVd8AEIoVQSrXOGCGLtDJGt2hkeEJekS+dlKOn3GCqX/oyiXKxf2qfDeLzZXDjIH9ojX+1GMNYuGWtXjLXv+7/NbPAL7SZ9DEW68ORH5KOtTZe2Vq2ji0cHWZX+Pnr6Um8Hn8UbzuItZ/GOs3jPWXzgLD4yFn/B+SAdi5ecxSvO4jl32AvOg+hYPOcOazl3WMu5w1rOHdZy7rCOc4d1nDus49xhHecOe8E+5x2L59xhXedTpY9JfHh+lrb0nb9h47IEbrWQmXjyN6yJ6U6wRtfFK6OXZXNlzHppr36IN5zFW87iHWfxnrP4wFl8ZCw+CM7iJWfxirN4zh32gi0kOxbPucMGzh02cO6wgXOHDZw7bOTcYSPnDhs5d9jIucNesJFdx+I5d9jIucNGzh02cu6wkXGHVYJxh1WCcYdVgnGHVYJxh1WCcYdVgnGHVYJxh1WCcYdVgnGHVYJzh5WcO6zse7axKj2gY3Uuvu973pnl77DKbXYdXsT3fc/Xxau+vY116Xkq67PbRvXtbXbEG87iO59t6uL79jY74vv2Njvi+57nd8T3Pc/Xxeu+vY2NSbzbHHewiO979WBHfN/zvFufnHY+bsUXdAiZdmMR2tUHq5ge4FbRrp9eU6Vnsq0Ii7m1Isbt4DPDvtsND4Z9dz0eDPtuvjwYdp71WDDsPHJyYGj6dkQ8GPZtzHgw7HsFhgfDvheCeDA0AzF0695RTwefKx0pTdQrHcnz1ysdyZlvKg0uq3Qk/5y2VpNSZH+bMCO53GqldiQvWq90JMe4qVRm6352JF8XxVppNvfakdyXM7VKzTSVDuWRqpUO5ZGqlQ7lkaqVjuSR3KpD5f10JI9UrdSN5JHqlQ7kkeR6NKN0WZZxA3mknUoH8kg7lZoxK/U6q3QgjyR9SDpilmXcQB5pp9KBPNJOpQN5pCeVZm7QDeSRpF9ESyWyudcP5JGklbVKh/JI1UqH8kjVSofySNVKzTSVjuSR7OZ0CZlVOpJHqlc6kkeqVzqSR6pXOpBHUjq5QWWzSjvfC+66Sm36rIjymcPvfOO4Xz+YVrhy/bMrne8yd02lLsjlyi6ozQ3wo9DOLdJxhZpZCu3cIB1XaOf+6LhCO7dHxxXK9antqwvl+oR3qdD0pycXNsdq/ii08138Dix0HGu0U+hIzqha6EjOqFqomaXQkZxRtdCRnFG10JGcUbXQkZxRtdBJnJHufPfFAwudxBnpznd1PLDQSZyRFmaWQidxRrrzXSgPLHQSZ6Q7393ywEJncUad75p5YKGzOCM5izOSszgjaWYpdBZnJGdxRnIWZ8R2D+SrC53FGalZnJGaxRl1vlv2gYXO4ow634X7qkKjSJ9hiDIrdCBnVC90IGdUL3QgZ1QvdCBnVC90IGdULbTz3cgPLJSrYTiL52oCzuINZ/Fcm/VZPNcGfBZPPgXbdGlrVaiLt8ovD3ycxort4Efx9FsaXyX+NBsug7VRmXjZt3jpa+JV3+KFWcXvvEGiTg0tniairFLd9xsk2lSpkJl4w1m85SzecRbvOYsPnMV33o6r4m3f7XhHfN/teEd83+14RzznDku/Q+qR4jl3WMu5w1rOHdZy7rCWc4d1nDvsBVtCarEjXujNUQFrVjtvVpiPXreWEGuC1cIVryxc2tdHSLE+EqtVaRlUp73Qjd5c25RWYIJK5yWGza+nOFiGsIiWcbOdfHFwMMuFg31y3TNuA9zH4j4JTZswC50D9wBOCzwAOC3wCOCkwC/Y3xLADwUuAZwWuALwo4Gvm3gLZzPgcOHEwA2A0wK3AE4L3AE4LXAkTWLgSJrEwJE0aYEHJE1i4EiahwN360niQWXAkTSJgSNpEgM3AE4LHEmTGDiSJjFwJE1i4EiaxMCRNF8y+OTAI5ImbdKMSJrEwJE0iYEjaRIDNwBOCxxJkxg4kiYxcCRNYuBImsTAkTRJgRuBpEkMHEmTGDiSJjFwJE1i4AbAaYEjaRIDR/AhBo7gQwwcwYcWuETwIQaO4EMM3EwKXPtl9w6lg86wzOoljEw6jDIZllk7/g6WWftyHYuatXvuYJm1x+1gmXUJbgfLrAtlO1gMsJSwzLrotINl1g8h7GCByy1igcstYoHLLWHRcLlFLHC5RSxwuUUscLlFLGZWLOkokROhvRVOmdZOpfQhYzitJb6GoVo3M1ZOZgyn9c8HMpzWbB/IcFpnfiDDaW38cQzNtJ7/KoY+Vahi1pfNtJbvGoZWikWGlfl9aMCwmSH8YTtD+MN2hvCH7QzhDy9g6HTyNs6JjCH8YTNDC3/YznDaBeQDGU672nwgQ+SUdoYGDJsZIqe0M0ROaWeInNLOEDmlnSFySjNDh5zSzhA5pZ0hcko7Q+SUdoYGDJsZIqe0M0ROuYRhSE+2eqEyhsgp7QyRU9oZIqc0M5z2+OYjGSKntDNETmlniJzSztCAYTNDeJsLGBqVGBoj64ODWZ7DCDbbUWXaYxpfDPfOzj7THtP4asDR2IiBowseDbz+KN20xzS+GnCsAxIDx6IhMXC4cGLgWI6kBT7tMY2vBhxJkxg4kiYxcCRNYuAGwGmBI2k2AT8zRHhsZ4g82M4QEa+dIVJbK0M77SmGRzJEtrqEofWJoRcZQ8SldoZIQO0MDRg2M0ROaWeInNLOEDmlnSFySjtD5JRmhtMeOngkQ+SUdobIKe0MkVPaGRowbNwY0UrklHaGyCntDJFT2hnCYz9n+Ihl3tNG61jghItYYG6LWOBXi1jQ+gmfFbTznkv5ck9SSZM06wz4vGcYvhZwdGVi4Oj3xMDhJIiBGwCnBY41NdLnvS1OoaQGDh9ODBwfQSAGjrVUWuA4OZMaOJImMXAkTWLgSJrEwA2AHw3cxRWHyoAjaRIDR9IkBo6kSQwcSZMYOJImLXCcwUsNHEmTGDiS5ksGnwJwJE3apIlzg6mBI2kSA0fSJAaOpEkMHEmTGDiSJi1wnKJMDRxJkxg4kiYxcCRNYuAGwGmBI2kSA0fSJAaOpEkMHEmTFjiOZaYGjuBDDBzBhxg4gg8xcAPgdMC/n77737vP9+/ef/zw5fSax3/85+H3r/efHn5++/X/f//4l9PgfwE=","brillig_names":["player_hand"],"assert_messages":{"285":"push out of bounds","314":"attempt to add with overflow","142":"Storage slot 0 not allowed. Storage slots must start from 1.","43":"Function player_hand can only be called statically","302":"Array index out of bounds","37":"Not initialized","226":"Array index out of bounds","319":"Array index out of bounds","328":"attempt to add with overflow","430":"Array index out of bounds","470":"attempt to add with overflow","523":"attempt to add with overflow","336":"attempt to add with overflow","557":"Array index out of bounds","394":"Array index out of bounds","359":"attempt to add with overflow","452":"Array index out of bounds","257":"attempt to add with overflow","385":"Array index out of bounds","347":"Array index out of bounds","376":"Array index out of bounds","411":"attempt to add with overflow","274":"attempt to add with overflow","539":"Array index out of bounds","548":"Array index out of bounds","297":"attempt to multiply with overflow","574":"attempt to add with overflow","592":"Stack too deep"}},{"name":"initialize_deck","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":null},"bytecode":"JgAEAQInAASAQwABJgAEAwAmAgQAASYCBAACHxgAAgABgEMkAAAACDoAgEMAACQAAACUHgIAAAIeAgAAAzI4AAIAAwAEJgIBAQIjAgAAABAABCYCBAADOwkAAywIAQImAgQKAwAQAQMBJgMEAQIAKAICAywMAwQmAgAABSwOBQQAKAQCBCwOBQQAKAQCBCwOBQQAKAQCBCwOBQQAKAQCBCwOBQQAKAQCBCwOBQQAKAQCBCwOBQQAKAQCBCwOBQQAKAQCBCwOBQQsDQIDACgDAgMsDgMCLAgBAwAAAQIBLA4CAyYCAgACJgIEBwQsCAEGJgIECAcAEAEHASYDBAEGACgGAgcsDAcILA4CCAAoCAIILA4CCAAoCAIILA4CCAAoCAIILA4CCAAoCAIILA4CCAAoCAIILA4CCAAoCAIILA4CCCYCBAEHJgIEAAgsDAgBIgAAAEcMOAEECSMCAAAAdgAJIgAAAEosDQMCJgIAKgYtBAACgAMnAAQACoAEJAAAAJotCIAFAAkAKAkCCgA4CgQLLA4GCywNCQIAKAICAiwOAgkmAgQIAgAoCQIGADgGAgosDgUKLAwJBCwOBAMmAgQJAiYCAAEDLAwIASIAAABgDDgBAgUjAgAAAGQABSIAAABjJRwMAAEFADgDBQYmAgQJCAw4AQgJIwIAAABrAAkmAgQACjsJAAoAKAQCCAA4CAEJLA0JBS8MAAUABgA4AQcFDjgBBQYjAgAAAHQABiYCBAAIOwkACCwMBQEiAAAAYCwNAwkmAgQHCww4AQsMIwIAAAB8AAwmAgQADTsJAA0AKAYCCwA4CwEMLA0MChwMAAoLJgIECQwMOAEMDSMCAAAAhQANJgIEAA47CQAOLQQACYADJwAEAAqABCQAAACaLQiABQAKACgKAgwAOAwBDSwOCw0AOAEHCQ44AQkLIwIAAACRAAsmAgQADDsJAAwsDgoDLAwJASIAAABHJwAEeACABA0AAACABIADIwAAAACZgAMnAAQAAIAEPAEAAIAEJS0BgAOABgsAgAYAAoAHIwAAAACegAciAAAAoC0AgAOABSIAAACuLQAAAYAFAQAAAYAEAAEBAIADgASACS0AgAOACi0AgAWACwsAgAqACYAMIwAAAACsgAwtAYAKgAgtAoAIgAsBAIAKAAKACgEAgAsAAoALIgAAAKUnAQQAAYAFIgAAAK4lLQAYyhjK","debug_symbols":"1ZzbiuJAFEX/Jc8+VNWpq78yNI12axMQbdQeGMR/n+hYMRPtc1602edFEt2klrmtgmxyaN4X86+P13a93Oya6a9Ds9q8zfbtZt2tHY6TZr5tV6v243X4dWNOH+Uc333O1qe13X623TdTG4uZNIv1e7eYjOk2sGxXi2aawnFyGzYm1LBxoQ/bUO6kKVPddLdY+nRJd8KRfLyEI0U3DL9MGmsewJ5dDXfwP8huH8Dubb/fo7Tfrcu+pskbnj1Fly7hFJMZs7uHslvzP/tpBHr6CP7pI4SnjxDvjpBzfzkWk4URqD/QlgJdR8j2TjoUUy7pUJznzyFKVMOUBptO7syeFLNnxexFL7szitmtYnanmJ0Us3vF7EExu2KvOsVedYq96hR7lRR7lRR7lRR7lRR7lRR7lRR7lRR7lRR7lRR7lRR71Sv2qlfsVa/Yq16xV71ir3rFXk3Y12r2ubLn6Mfs2OdMztSzFzdmhz5nvLGV3RtKY3bouZjADj0XE9ih52ICO/RcjGfP0HMxgR36/i6wQ8/FBHbouZjADu1VgV2xVzO4V2Pu2Uscs4N7lWUH9yrLDu5Vjr2Ae5VlB/cqy/7j95mcalMu5CKwhxhr2axbDMPwy6m3Z6Dh0/UoJVtu4C32ni+eg3fYe97ZHp5uaoeGNMN7zfBBMzz2rVKAT5rhs2b4ohjeYhs2ZnOFt3y4eFv/afHhtkcPruNv/+kZHlvHAjy2jgV4bB0L8Ng6FuCx2wjs0yoLXp/PpXJQcXYMD96fF+DBH3Ly8NiNBAEeu5IgwHvN8NilBAEeu+0nwGPX/Ybwg8l/hQc3LNepsOBFeh4evEkvwIMblocHNywPD25YHh7csDw8uGF5eHDD8vDghuXhNRsWvFLPw4N36gV4zYYFb9UL8JoNC96rF+DVGvbYrf2ebdvZfLW4vEZp+bV+G7xVaf/n898vXfgv","brillig_names":["initialize_deck"],"assert_messages":{"144":"attempt to add with overflow","152":"Stack too deep","106":"Array index out of bounds","15":"Not initialized","132":"Array index out of bounds","115":"attempt to add with overflow","123":"Array index out of bounds"}},{"name":"view_deck","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"drawn_cards_bitmap","type":{"kind":"array","length":7,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"deck_seed","type":{"kind":"field"}},{"name":"draw_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"CardNote::CardNote::Deck"},"visibility":"public"}},"bytecode":"JgAEAQInAASATAABJgAEAwAmAgQAASYCBAACHxgAAgABgEMkAAAAEQAoAQIEJwIEgEMABSYCBAcGLQQABIADLQQABYAELQQABoAFJAAAAK0tBAACgEotBAADgEs6AIBDAAkkAAAAuB4CAAACHgIAAAMyOAACAAMABCYCAQECIwIAAAAZAAQmAgQAAzsJAAMeAgoAAiYCAAEDCjgCAwQjAgAAAB8ABCYCBAAFOwkABSYCAAACLAgBBCYCBAoFABABBQEmAwQBBAAoBAIFLAwFBiwOAgYAKAYCBiwOAgYAKAYCBiwOAgYAKAYCBiwOAgYAKAYCBiwOAgYAKAYCBiwOAgYAKAYCBiwOAgYAKAYCBiwOAgYAKAYCBiwOAgYsDQQFACgFAgUsDgUELAgBBQAAAQIBLA4EBSYCBAACJgIEAQQmAgQJBiwMAgEiAAAAQgw4AQYHIwIAAACVAAciAAAARSwNBQMmAgIABSwIAQYmAgQIBwAQAQcBJgMEAQYAKAYCBywMBwgsDgUIACgIAggsDgUIACgIAggsDgUIACgIAggsDgUIACgIAggsDgUIACgIAggsDgUIACgIAggsDgUILA0GBwAoBwIHLA4HBiwIAQcAAAECASwOBgcmAgQHBSwMAgEiAAAAYww4AQUCIwIAAAB1AAIiAAAAZgAoAwICADgCBQQsDQQBJgIECAIAKAMCBQA4BQIGLA0GBBwMBAQDHAwAAwIcDAQCAywNBwIsDAEELAwCASwMBAIlLA0HAiYCBAkIDDgBCAkjAgAAAHsACSYCBAAKOwkACgAoAwIIADgIAQksDQkGHAwCBgkcDAAJCBwMAggGJgIEBwkMOAEJCiMCAAAAhgAKJgIEAAs7CQALLQQAAoADJwAEAAiABCQAAAC+LQiABQAIACgIAgkAOAkBCiwOBgoAOAEEAg44AQIGIwIAAACSAAYmAgQACTsJAAksDggHLAwCASIAAABjLA0FBxwMAAEIADgDCAkuDAAJAAgmAgQJCgw4AQoLIwIAAACeAAsmAgQADDsJAAwtBAAHgAMnAAQACoAEJAAAAL4tCIAFAAkAKAkCCgA4CgELLA4ICwA4AQQHDjgBBwgjAgAAAKoACCYCBAAKOwkACiwOCQUsDAcBIgAAAEIBAIADgAWABy0AgAOACC0AgASACQsAgAiAB4AKIwAAAAC3gAotAYAIgAYtAoAGgAkBAIAIAAKACAEAgAkAAoAJIgAAALAlJwAEeACABA0AAACABIADIwAAAAC9gAMnAAQAAIAEPAEAAIAEJS0BgAOABgsAgAYAAoAHIwAAAADCgAciAAAAxC0AgAOABSIAAADSLQAAAYAFAQAAAYAEAAEBAIADgASACS0AgAOACi0AgAWACwsAgAqACYAMIwAAAADQgAwtAYAKgAgtAoAIgAsBAIAKAAKACgEAgAsAAoALIgAAAMknAQQAAYAFIgAAANIlLQAYyhjK","debug_symbols":"1ZzdThsxEEbfZa9zYXtm7DGvUlVVgIAiRQFBqFQh3r0birdpNhoLGtB8N2iXzMYn8c8ZyRk/D9ery6fbH+vtzd3jcPHtedjcXS1367vtePf8shguH9abzfr2x+G/h7D/E/U1/vF+ud3fPu6WD7vhIuYaFsNqez1elhDGd7hZb1bDRZGXxTw4BGnBIckUHKWeiCal9tbjZZ2iazkRnInzW3CmnA6Dvy+GWM/ArqkFj/Bfx57CGdg5Tt977n3vMSm3aOJgs5ecyltwySUcs8ezssfwL/u+hfTpLdCnt8Cf3oL8dwsSYxsVEqk3KlLVNiooxeNRkd9Js3+mfOAZ/cAz9f3PUPjAMydnRkqxrQQpkXb6PDJNfZ7/BkeNp/pPQpuoIknt/pMkbbEbL+mo/ygBsxMwOwOzCzB7BmYvwOwKzF5x2TkAswN7lYG9ysBeZWCvMrBXGdirDOxVBvYqA3tVgL0qwF4VYK8KsFcF2KsC7FUB9qoAe1WAvSrAXs3AXs3O52qpE7se7+5k52Omts1GoXC8B1G+fMxwnYaBMNnsTNS2c8bLA470yh6B2RMwOwGzMzC7ALNnYPYCzK7A7BWXXYG9qsBeVWCvKrBXFdirCuxVBfaqAntVgb2qwF6twF6twF6twF6twF6twF6twF6tvtdInn5Wz8z5iD0G35M1h/YLas5JZ/C+Z2sH3vd07cD7nq85T/M1a53B+06EO/C+M+EOvO9UuAPve50/hK+zdT76ToY78L6z4Q68c8Pa8L5XGzu3ib5XG9Y6wdeZYaPzrNKET75Xmw6879WmA+97tenA+87nO/CMDO87n+/A+87nD+Al8AzeuWFteBjDnoJ3btgs05jXWW5Dzg1rwzs3rA3v3LA2vHPD2vDODWvDOzesDe/csDa8c8Pa8M4Na8MjG5aRDcvIhmVkwzKyYb++rPuc8MiGZWTDeq8wtipyovMSY6Kpm4hnh/Q5rzGmWCx430XGNO2Aj/CdCVIptG6qRDL7pM5Lkq2yr+i9JtmGd16UbMM7r3S04Z2XJdvwzuuSbXjgItPovTLZhnd+5IcN7/zMDxse2bAZ2bAZ2bDezxKw4ZENm5ENi3yMQyywhn0Z734uH9bLy83q7fD9m6ft1cFZ/Ltf939eGYN/Aw==","brillig_names":["view_deck"],"assert_messages":{"157":"Array index out of bounds","122":"Array index out of bounds","145":"attempt to add with overflow","30":"Function view_deck can only be called statically","24":"Not initialized","133":"Array index out of bounds","188":"Stack too deep","169":"attempt to add with overflow"}},{"name":"dealer_hand","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"cards","type":{"fields":[{"name":"storage","type":{"kind":"array","length":6,"type":{"fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}],"kind":"struct","path":"CardNote::CardNote::Card"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"}},{"name":"bust","type":{"kind":"boolean"}}],"kind":"struct","path":"CardNote::CardNote::Hand"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7Zzdbts4EIXfxde5IIcc/uRVFovCadPCgOEUibvAIsi7V3Yj2bFcEk4ZY86wN4Edj6TzUbTOkWTN8+LL/d2Pb59Wm68PT4vbf54X64fPy+3qYTO8e365Wdw9rtbr1bdPx/9emN0fm/b1T9+Xm93bp+3ycbu4tSGbm8X95svwMhozrOHran2/uI38cjMvNobHYkM8FVvOZ6pdcuOqh5d5qs7xTHFwPrwWBxfouPjfm4XNDbQnGosH8dfTTqaBdm+ncQ+1cbeU/FjtvClrj4Hia3EM0Zxqt021W/NW+24L9OFbcB++Bf/hW+A/3gJbO84Ktq42KyincVY4sqezIlyoZrdMfMcy6R3L5MuXceYdy5z/ZuQ0jhsZS5V9br2b9nlIh32e7Ln9x2b8ojJTKu8/Jh4PdsNLd7L/HAFrd8DaPbB2BtYegLVHYO0JWHvG1e4NsHZgX/XAvuqBfdUD+6oH9lUP7Kse2Fc9sK96YF9lYF9lYF9lYF9lYF9lYF8Nwud7zJP2dHrVNQgf9zzeBGBnTq8NhqvnGZ+nacDelbWTd+NlVvL+sOpIe+0BWHsE1p6AtWdc7dEAa7fA2glYuwPW7oG1A/tqBPbVCOyrEdhXI7CvJmBfTcC+moB9NQH7agL21QTsqwnYVxOwryZgX03AvpqBfTUD+2oG9tUM7KsZ2FczsK9mYF/NwL6agX01A/uqNcDGag2ws1oDbK3WyJ7zTONTOcPt4Zl4K3vkgx9vslJgnomXnWoq4mXbK4c8TZs4nzay/bUiXrbBVsQLP9oUxZNsh62Il+2wFfGyj/MV8bKP8xXxXrb4PIkPRDPxss9fK+JlH+cDT8EsxHws/owOY0dSa1woF1N2U/DIfPhpGoVzmk0awy2bnI+L92Mo224gxtDJdj2MMZRtvhhjKPxcD2IMhZ9yQoyh/zuGfzyGsoMZxhjKvgKDMYayLwRhjKGm85RwaI31tnhPqulsokjqNWX+MqmmZH5EmsKMVFN+zmcbbY2kmlJumdR3Q6opMR6R2tl1P68p1x26rw23fmakmtJX8CVSVRmpSKoqI5VIWVVGKpKqykhFUk0ZKRx00MxPWVNGKpP6bkgVZSTLh0bPYXYuw4oyUoVUUUaqkCrKSMek0c1IFWUkG9OkI8/OZYKijFQhVZSRKqSKMtIb0lkaDIoyko1jcyhLZnbsvX6zqo889toSqaqMVCRVlZGKpKoyUpFUVUYqkmrKSDxdBSVrT0mFN/BqSaopI5VJNWWkMqmijERuSoPEc1KviJSn34pQnCV84W3Kfv9g2pk1l3+7Iryp2SWkIdlxzSHR0QT4BSo8IrUDFZ6Q2oEKD0jNQIU3YmsIKjwetQNFfWr7YlDUJ7zPgU63nkJKfArqewHVE40qoJqSURFUUzIqgmpKRkVQTcmoBCq8lV5DUE3JqAiqKRkVQXtJRsLb/zUE7SUZCW8s2BC0l2QkvGVhQ9BOkhEJ74XYELSTZETCeyw2BO0kGZHxvYB2kozIdJKMyHSSjMh0koxIeBfcdqC2l2Rke0lGsD2QLwbtJRlZ3wtoL8lIeLfshqC9JCPhXbgvAs1m+g1DtjNQRcmoCCq8u3dDUEXJqAyqKBmVQRUlozKo7wUUNTDsxaOGgL14VGPfi0c165146Y3Gy+KvfghmEyfxlMrimeL4wMdQa46L9+K9aPHOTbvJeZqJZ9nibSyJD7LFG38QX/mCZDcZWnaOZ6RR9hck80Rq7Ex8QhafgcVfvxNtS/EWWTwhixdux2Xxsu24Il62HVfEy7bjinhkh/XIDuuRHZaRHZaRHZaRHZaRHfb6PUFbiX8Z3v23fFwt79b3T8Myuw9/bD5vVw+b17fb/7//+mQo/gk=","brillig_names":["dealer_hand"],"assert_messages":{"253":"attempt to add with overflow","151":"attempt to add with overflow","241":"Array index out of bounds","168":"attempt to add with overflow","191":"attempt to multiply with overflow","179":"push out of bounds","208":"attempt to add with overflow","272":"Stack too deep","196":"Array index out of bounds","30":"Function dealer_hand can only be called statically","222":"attempt to add with overflow","24":"Not initialized","120":"Array index out of bounds","213":"Array index out of bounds","230":"attempt to add with overflow"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"owner","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"BlackJack"}},{"name":"fields","value":{"fields":[{"name":"card_deck","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"player_hands","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}],"kind":"struct"}},{"name":"dealer_hand","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000b"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[{"name":"player","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BlackJack::player_hand_parameters"}},{"name":"return_type","type":{"fields":[{"name":"cards","type":{"fields":[{"name":"storage","type":{"kind":"array","length":6,"type":{"fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}],"kind":"struct","path":"CardNote::CardNote::Card"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"}},{"name":"bust","type":{"kind":"boolean"}}],"kind":"struct","path":"CardNote::CardNote::Hand"}}],"kind":"struct","path":"BlackJack::player_hand_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"player","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BlackJack::constructor_parameters"}}],"kind":"struct","path":"BlackJack::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BlackJack::initialize_deck_parameters"}}],"kind":"struct","path":"BlackJack::initialize_deck_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BlackJack::view_deck_parameters"}},{"name":"return_type","type":{"fields":[{"name":"drawn_cards_bitmap","type":{"kind":"array","length":7,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"deck_seed","type":{"kind":"field"}},{"name":"draw_counter","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"CardNote::CardNote::Deck"}}],"kind":"struct","path":"BlackJack::view_deck_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BlackJack::dealer_hand_parameters"}},{"name":"return_type","type":{"fields":[{"name":"cards","type":{"fields":[{"name":"storage","type":{"kind":"array","length":6,"type":{"fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}],"kind":"struct","path":"CardNote::CardNote::Card"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"std::collections::bounded_vec::BoundedVec"}},{"name":"bust","type":{"kind":"boolean"}}],"kind":"struct","path":"CardNote::CardNote::Hand"}}],"kind":"struct","path":"BlackJack::dealer_hand_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"player","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BlackJack::begin_game_parameters"}}],"kind":"struct","path":"BlackJack::begin_game_abi"}]}},"file_map":{"119":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"124":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"132":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"},"159":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"160":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"165":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"},"173":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr","source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    storage::map::derive_storage_slot_in_map,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<T, N> for Map<K, T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"},"181":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicMutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"223":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"303":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"305":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"306":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr","source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"},"312":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr","source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    },\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n"},"313":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n    utils,\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    ec::{pow, sqrt},\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"315":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr","source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"316":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr","source":"use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"},"320":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::default::Default;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"322":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedEncryptedLogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__VK,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    proof::verification_key::VerificationKey,\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"323":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"340":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator, traits::Serialize,\n    },\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"7":{"path":"std/collections/bounded_vec.nr","source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n"},"72":{"path":"/Users/niallcheetham/Dev/aztec/blackjack/blackjack/src/CardNote.nr","source":"// CardNote.nr\npub mod CardNote {\n    use dep::aztec::{\n        oracle::random::random,\n        prelude::{PublicContext, PublicMutable},\n        protocol_types::{\n            address::AztecAddress,\n            constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n            traits::{Deserialize, FromField, Serialize, ToField},\n        },\n    };\n    use std::hash::poseidon2;\n\n    global MAX_CARDS_IN_HAND: u32 = 6;\n    global BITS_PER_FIELD: u32 = 255;\n    global TOTAL_CARDS: u32 = 52;\n    global FIELDS_FOR_DECK: u32 = 7;\n    global MAX_DRAW_ATTEMPTS: u32 = 5;\n    global BITS_PER_BYTE: u32 = 8;\n    global NUM_BITMAP_BYTES: u32 = (TOTAL_CARDS + BITS_PER_BYTE - 1) / BITS_PER_BYTE; // 7 bytes\n\n    //-------------------------------CARD-----------------------------------\n\n    #[derive(Serialize)]\n    #[derive(Deserialize)]\n    pub struct Card {\n        pub rank: Field,\n        pub suit: Field,\n    }\n\n    impl FromField for Card {\n        fn from_field(field: Field) -> Card {\n            let value_bytes: [u8; 32] = field.to_le_bytes();\n            let rank = ((value_bytes[0] as u32) + (value_bytes[1] as u32) * 256) % 14;\n            let suit = ((value_bytes[2] as u32) + (value_bytes[3] as u32) * 256) % 4;\n            Card { rank: rank as Field, suit: suit as Field }\n        }\n    }\n\n    impl ToField for Card {\n        fn to_field(self) -> Field {\n            self.rank as Field + self.suit as Field * 65536\n        }\n    }\n\n    fn card_id(rank: u8, suit: u8) -> u8 {\n        (suit as u8) * 13 + (rank as u8) - 1 // Ranks from 1 to 13\n    }\n\n    fn id_to_card(card_id: u8) -> Card {\n        let rank = (card_id % 13) + 1;\n        let suit = card_id / 13;\n        Card { rank: rank as Field, suit: suit as Field }\n    }\n\n    //-------------------------------HAND-----------------------------------\n\n    pub struct Hand {\n        cards: BoundedVec<Card, MAX_CARDS_IN_HAND>,\n        bust: bool,\n    }\n\n    impl Serialize<MAX_CARDS_IN_HAND> for Hand {\n        fn serialize(self) -> [Field; MAX_CARDS_IN_HAND] {\n            let mut fields = [Field::empty(); MAX_CARDS_IN_HAND];\n            //only serialize the cards that exist\n            for i in 0..self.cards.len() {\n                fields[i] = self.cards.get(i).to_field();\n            }\n            fields\n        }\n    }\n\n    impl Deserialize<MAX_CARDS_IN_HAND> for Hand {\n        fn deserialize(fields: [Field; MAX_CARDS_IN_HAND]) -> Self {\n            let mut cards = BoundedVec::new();\n            //only deserialize the non empty fields\n            for i in 0..fields.len() {\n                let field = fields[i];\n                if field != Field::empty() {\n                    cards.push(Card::from_field(field));\n                }\n            }\n            Hand { cards, bust: false }\n        }\n    }\n\n    impl ToField for Hand {\n        fn to_field(self) -> Field {\n            // Serialize the cards array into fields\n            let mut card_fields = [Field::empty(); MAX_CARDS_IN_HAND];\n            for i in 0..self.cards.len() {\n                card_fields[i] = self.cards.get(i).to_field();\n            }\n\n            // Hash the serialized data\n            poseidon2::Poseidon2::hash(card_fields, MAX_CARDS_IN_HAND)\n        }\n    }\n\n    pub fn new_hand() -> Hand {\n        Hand { cards: BoundedVec::new(), bust: false }\n    }\n\n    //-------------------------------DECK-----------------------------------\n    pub struct Deck {\n        // Bitmask to track used cards\n        drawn_cards_bitmap: [u8; NUM_BITMAP_BYTES],\n        deck_seed: Field,\n        draw_counter: u32,\n    }\n\n    impl Serialize<NUM_BITMAP_BYTES + 2> for Deck { // Implement Serialize with explicit size\n        fn serialize(self) -> [Field; NUM_BITMAP_BYTES + 2] {\n            let mut fields = [Field::empty(); NUM_BITMAP_BYTES + 2];\n            // Use first 5 indices for bitmap\n            for i in 0..NUM_BITMAP_BYTES {\n                fields[i] = self.drawn_cards_bitmap[i] as Field;\n            }\n            // Use last 2 indices for seed and counter\n            fields[NUM_BITMAP_BYTES] = self.deck_seed;\n            fields[NUM_BITMAP_BYTES + 1] = self.draw_counter as Field;\n            fields\n        }\n    }\n\n    impl Deserialize<NUM_BITMAP_BYTES + 2> for Deck {\n        fn deserialize(fields: [Field; NUM_BITMAP_BYTES + 2]) -> Self {\n            let mut drawn_cards_bitmap = [0 as u8; NUM_BITMAP_BYTES];\n            // Get bitmap from first 5 indices\n            for i in 0..NUM_BITMAP_BYTES {\n                drawn_cards_bitmap[i] = fields[i] as u8;\n            }\n            // Get seed and counter from last 2 indices\n            let deck_seed = fields[NUM_BITMAP_BYTES];\n            let draw_counter = fields[NUM_BITMAP_BYTES + 1] as u32;\n            Deck { drawn_cards_bitmap, deck_seed, draw_counter }\n        }\n    }\n\n    impl Deck {\n        fn new(deck_seed: Field) -> Self {\n            // Initialize with all zeros\n            let drawn_cards_bitmap = [0 as u8; NUM_BITMAP_BYTES];\n            let draw_counter = 0;\n\n            Self { drawn_cards_bitmap, deck_seed, draw_counter }\n        }\n    }\n\n    impl ToField for Deck {\n        fn to_field(self) -> Field {\n            let mut card_fields = [Field::empty(); FIELDS_FOR_DECK];\n            for i in 0..self.drawn_cards_bitmap.len() {\n                card_fields[i] = self.drawn_cards_bitmap[i].to_field();\n            }\n            card_fields[FIELDS_FOR_DECK] = self.deck_seed;\n            card_fields[(FIELDS_FOR_DECK + 1)] = self.draw_counter.to_field();\n            // Hash all card fields into a single Field\n            poseidon2::Poseidon2::hash(card_fields, FIELDS_FOR_DECK)\n        }\n    }\n\n    //-------------------------------BITMASK UTILITIES-----------------------------------\n    fn is_card_used(deck: &mut Deck, card_index: u8) -> bool {\n        assert(card_index as u32 < TOTAL_CARDS as u32); // Ensure valid card index\n        let field_index = (card_index / 8) as u32;\n        assert(field_index as u32 < FIELDS_FOR_DECK as u32); // Ensure valid field index\n        let bit_index = card_index % 8;\n        let current_field = deck.drawn_cards_bitmap[field_index as u8];\n        (current_field & (1 << bit_index)) != 0\n    }\n\n    fn set_card_used(deck: &mut Deck, card_index: u8) {\n        assert(card_index as u32 < TOTAL_CARDS as u32); // Ensure valid card index\n        let field_index = (card_index / 8) as u32;\n        assert(field_index < FIELDS_FOR_DECK as u32); // Ensure valid field index\n        let bit_index = card_index % 8;\n        let mut current_value = deck.drawn_cards_bitmap[field_index as u8];\n        current_value |= 1 << bit_index;\n        deck.drawn_cards_bitmap[field_index as u8] = current_value;\n    }\n\n    //---------------------------FIESTEL NETWORK-----------------------------------\n\n    fn feistel_network(seed: Field, input: u64) -> u64 {\n        let mut left = (input) & 0xFFFF_FFFF;\n        let mut right = (input >> 32) & 0xFFFF_FFFF;\n\n        // Round 1\n        let temp = right;\n        right = left ^ (feistel_function(right, seed, 0)) as u64;\n        left = temp;\n\n        // Round 2\n        let temp = right;\n        right = left ^ (feistel_function(right, seed, 1)) as u64;\n        left = temp;\n\n        // Round 3\n        let temp = right;\n        right = left ^ (feistel_function(right, seed, 2)) as u64;\n        left = temp;\n\n        // Combine left and right\n        let output = (left << 32) | right;\n        // Map output to 0..51\n        (output % 52) as u64\n    }\n\n    fn feistel_function(value: u64, seed: Field, round: u32) -> Field {\n        let value_field = value as Field;\n        poseidon2::Poseidon2::hash([value_field, seed, round.to_field()], 3)\n    }\n\n    //-------------------------------DRAW CARD-----------------------------------\n\n    pub fn generate_card(deck_seed: Field, draw_counter: u64) -> Card {\n        let card_index = feistel_network(deck_seed, draw_counter);\n        id_to_card(card_index as u8)\n    }\n\n    pub fn draw_card(mut deck: Deck) -> (Card, Deck) {\n        let mut card_index = 0;\n        let mut unique_card_found = false;\n        let mut final_counter = 0;\n\n        // Instead of breaking, we'll use the first valid card we find\n        for attempt in 0..MAX_DRAW_ATTEMPTS {\n            if !unique_card_found {\n                // Only process if we haven't found a card yet\n                let current_draw_counter = deck.draw_counter + attempt;\n                let current_card_index =\n                    feistel_network(deck.deck_seed, current_draw_counter as u64) as u8;\n\n                if !is_card_used(&mut deck, current_card_index) {\n                    // Found a valid card\n                    card_index = current_card_index;\n                    final_counter = current_draw_counter + 1;\n                    unique_card_found = true;\n\n                    set_card_used(&mut deck, card_index);\n                }\n            }\n        }\n\n        // Update the counter after the loop\n        if unique_card_found {\n            deck.draw_counter = final_counter;\n        } else {\n            deck.draw_counter = deck.draw_counter + MAX_DRAW_ATTEMPTS;\n        }\n\n        let card = if unique_card_found {\n            id_to_card(card_index)\n        } else {\n            Card { rank: 0.to_field(), suit: 0.to_field() }\n        };\n\n        (card, deck)\n    }\n\n    //-------------------------------CARD FUNCTIONS-----------------------------------\n\n    pub fn start_game(\n        deck: &mut Deck,\n        player_hand: &mut Hand,\n        dealer_hand: &mut Hand,\n        // card_deck_storage: PublicMutable<Deck, &mut PublicContext>,\n    ) -> (Hand, Hand, &mut Deck) {\n        // Draw two cards for the player\n        player_hand.cards = BoundedVec::new();\n        dealer_hand.cards = BoundedVec::new();\n\n        //draw two cards for the player\n        let (card1, updated_deck) = draw_card(*deck);\n        player_hand.cards.push(card1);\n        let (card2, updated_deck) = draw_card(updated_deck);\n        player_hand.cards.push(card2);\n\n        // Draw one card for the dealer (face-up)\n        let (dealer_card, final_deck) = draw_card(updated_deck);\n        dealer_hand.cards.push(dealer_card);\n\n        (*player_hand, *dealer_hand, deck)\n    }\n\n    // pub fn player_hit1(deck: &mut Deck, player_hand: &mut Hand) -> bool {\n    //     if let Some(card) = draw_card(deck) {\n    //         player_hand.cards.push(card);\n    //         // Check if player busts\n    //         check_bust(player_hand)\n    //     } else {\n    //         // Handle no more cards scenario\n    //         true // Assuming player busts if no more cards can be drawn\n    //     }\n    // }\n\n    pub fn player_hit(deck: &mut Deck, player_hand: &mut Hand) -> bool {\n        // Draw a new card\n        let (card, deck) = draw_card(*deck);\n        player_hand.cards.push(card);\n\n        // Check if player busts\n        check_bust(player_hand)\n    }\n\n    pub fn dealer_play(deck: &mut Deck, dealer_hand: &mut Hand) {\n        // Dealer must hit until the hand value is 17 or more\n        //need to make this a loop without while loop\n        if hand_points(dealer_hand) as u8 < 17 {\n            let (card, deck) = draw_card(*deck);\n            dealer_hand.cards.push(card);\n        }\n    }\n\n    fn card_points(card: Card) -> Field {\n        if (card.rank as u8 > 1) & (card.rank as u8 <= 10) {\n            card.rank\n        } else if card.rank == 1 {\n            11.to_field() // Ace as 11 initially\n        } else {\n            10.to_field() //Face cards (J,Q,K)\n        }\n    }\n\n    pub fn determine_winner(player_hand: &mut Hand, dealer_hand: &mut Hand) -> Field {\n        let player_points = hand_points(player_hand) as u8;\n        let dealer_points = hand_points(dealer_hand) as u8;\n\n        let player_bust = check_bust(player_hand);\n        let dealer_bust = check_bust(dealer_hand);\n\n        //player wins = 0\n        //dealer wins = 1\n        //push = 2\n        if player_bust {\n            1.to_field()\n        } else if dealer_bust {\n            0.to_field()\n        } else if player_points > dealer_points {\n            0.to_field()\n        } else if dealer_points > player_points {\n            1.to_field()\n        } else {\n            2.to_field()\n        }\n    }\n\n    pub fn hand_points(hand: &mut Hand) -> Field {\n        let mut points = 0;\n        let mut aces = 0;\n\n        // First pass: Calculate initial points and count the number of Aces.\n        for i in 0..hand.cards.len() {\n            let card_point = card_points(hand.cards.get(i));\n            if card_point == Field::from(11) {\n                aces += 1;\n            }\n            points += card_point;\n        }\n\n        // Adjust for Aces if points exceed 21.\n        // Adjust for Aces if points exceed 21.\n        let max_points = 21;\n        if (points as u8 > max_points) & (aces > 0) {\n            points = points - 10; // Adjust one Ace from 11 to 1\n        }\n        if (points as u8 > max_points) & (aces > 1) {\n            points = points - 10; // Adjust second Ace if needed\n        }\n        if (points as u8 > max_points) & (aces > 2) {\n            points = points - 10; // Adjust third Ace if needed\n        }\n\n        // The above conditions effectively handle up to 4 Aces in a hand.\n        points\n    }\n\n    pub fn check_bust(hand: &mut Hand) -> bool {\n        hand_points(hand) as u8 > 21\n    }\n\n    // pub fn generate_deck() -> Deck {\n    //     let mut deck: Deck = Deck { drawn_cards_bitmap: [0.to_field(); FIELDS_FOR_DECK] };\n\n    //     let mut index = 0;\n    //     for suit in 1..=4 {\n    //         for rank in 1..=13 {\n    //             let card_index = card_id(rank as u8, suit as u8);\n    //             set_card_used(&mut deck, card_index);\n    //         }\n    //     }\n    //     deck\n    // }\n\n}\n\n"},"75":{"path":"/Users/niallcheetham/Dev/aztec/blackjack/blackjack/src/main.nr","source":"//functionality that i need:\n\n//make it super simple to start similar to kits\n\n// Player hits/stands to beat dealer's hand by getting as close to 21 as possible.\n\n// Dealer must hit on and up to 16 and stand on 17.\n\n// Player can only double down on 9, 10, or 11.\n\n// Player can either double down or split, player cannot split then double down and vice versa.\n\n// Player cannot split then split again or double down more than once.\n\n// Player who splits Aces can receive only one more additional card on a hand.\n\n// Player can get insurance if dealer might have a BlackJack.\n\n// Aces are high unless card total is already greater than 11.\n\n// Blackjack payout is 3:2.\n\n// No surrender.\n\n//some finds here\n//i had to use my own serialisation and deserialisation for the deck, default ones were not working\n\nmod CardNote;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract BlackJack {\n\n    use crate::CardNote::CardNote::{\n        Card, check_bust, Deck, draw_card, Hand, hand_points, new_hand, start_game,\n    };\n    use dep::aztec::{\n        context::PublicContext,\n        macros::{functions::{initializer, private, public, view}, storage::storage},\n        prelude::{AztecAddress, Map, PrivateMutable, PublicImmutable, PublicMutable},\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        card_deck: PublicMutable<Deck, Context>,\n        player_hands: Map<AztecAddress, PublicMutable<Hand, Context>, Context>,\n        dealer_hand: PublicMutable<Hand, Context>,\n    }\n\n    #[private]\n    #[initializer]\n    fn constructor(player: AztecAddress) {\n        // let mut deck = Deck::new(); // Start with an empty deck\n        // storage.card_deck.write(deck);\n    }\n\n    //this is just because the constructor is private\n    #[public]\n    fn initialize_deck() {\n        let deck_seed = 42;\n        let mut deck = Deck::new(deck_seed); // Start with an empty deck\n        storage.card_deck.write(deck);\n    }\n\n    #[public]\n    #[view]\n    fn dealer_hand() -> Hand {\n        storage.dealer_hand.read()\n    }\n\n    #[public]\n    #[view]\n    fn player_hand(player: AztecAddress) -> Hand {\n        storage.player_hands.at(player).read()\n    }\n\n    #[public]\n    #[view]\n    fn view_deck() -> Deck {\n        storage.card_deck.read()\n    }\n\n    #[public]\n    fn begin_game(player: AztecAddress) {\n        //read existing\n        let mut deck = storage.card_deck.read();\n\n        let mut player_hand = new_hand();\n        let mut dealer_hand = new_hand();\n        // let mut card_deck_storage = storage.card_deck;\n        // let (updated_player_hand, updated_dealer_hand) = start_game(\n        //     &mut deck,\n        //     &mut player_hand,\n        //     &mut dealer_hand,\n        //     // card_deck_storage,\n        // );\n        // Draw cards and update deck with returned values\n        let (card1, updated_deck) = draw_card(deck);\n        let (card2, updated_deck2) = draw_card(updated_deck);\n        let (dealer_card, final_deck) = draw_card(updated_deck2);\n\n        player_hand.cards.push(card1);\n        player_hand.cards.push(card2);\n        dealer_hand.cards.push(dealer_card);\n\n        //store the deck\n        storage.card_deck.write(final_deck);\n        //store the hands\n        storage.player_hands.at(player).write(player_hand);\n        storage.dealer_hand.write(dealer_hand);\n    }\n\n    // #[public]\n    // fn player_hit(player: AztecAddress) {\n    //     let mut deck = storage.card_deck.modify();\n    //     let mut player_hand = storage.player_hands.at(player).modify();\n\n    //     // Draw a new card\n    //     player_hand.cards[player_hand.card_count.to_u32()] = draw_card(deck, deck.drawn_count);\n    //     deck.drawn_count += 1;\n    //     player_hand.card_count += 1;\n\n    //     // Check if player busts\n    //     if check_bust(player_hand) {\n    //         // Handle bust (e.g., end game, declare dealer winner)\n    //         // Implement game over logic here\n    //     }\n\n    //     // Update the player's hand in storage\n    //     storage.player_hands.at(player).write(player_hand);\n    // }\n\n    // #[public]\n    // fn player_stand(player: AztecAddress) {\n    //     // Proceed to dealer's turn\n    //     dealer_play(player);\n    // }\n\n    // #[public]\n    // fn dealer_play(player: AztecAddress) {\n    // let mut deck = storage.card_deck.modify();\n    // let mut dealer_hand = storage.dealer_hand.modify();\n\n    // // Reveal the dealer's hole card\n    // dealer_hand.cards[1] = draw_card(deck, deck.drawn_count);\n    // deck.drawn_count += 1;\n    // dealer_hand.card_count = 2;\n\n    // // Dealer must hit until the hand value is 17 or more\n    // while hand_points(dealer_hand).to_u32() < 17 {\n    //     dealer_hand.cards[dealer_hand.card_count.to_u32()] = draw_card(deck, deck.drawn_count);\n    //     deck.drawn_count += 1;\n    //     dealer_hand.card_count += 1;\n    // }\n\n    // // Update the dealer's hand in storage\n    // storage.dealer_hand.write(dealer_hand);\n\n    // // Determine the outcome\n    // determine_winner(player);\n    // }\n\n    // fn determine_winner(player: AztecAddress) {\n    // let player_hand = storage.player_hands.at(player).read();\n    // let dealer_hand = storage.dealer_hand.read();\n\n    // let player_points = hand_points(player_hand).to_u32();\n    // let dealer_points = hand_points(dealer_hand).to_u32();\n\n    // let player_bust = check_bust(player_hand);\n    // let dealer_bust = check_bust(dealer_hand);\n\n    // let outcome: &str;\n\n    // if player_bust {\n    //     outcome = \"Player busts. Dealer wins.\";\n    // } else if dealer_bust {\n    //     outcome = \"Dealer busts. Player wins!\";\n    // } else if player_points > dealer_points {\n    //     outcome = \"Player wins!\";\n    // } else if dealer_points > player_points {\n    //     outcome = \"Dealer wins.\";\n    // } else {\n    //     outcome = \"Push (tie).\";\n    // }\n\n    // // Handle payouts and game over logic\n    // // Emit event or log outcome\n    // // For simplicity, you can store the outcome in storage or emit it using an event\n    // }\n\n    //     #[public]\n    //     fn player_double_down(player: AztecAddress) {\n    //         let mut deck = storage.card_deck.modify();\n    //         let mut player_hand = storage.player_hands.at(player).modify();\n\n    //         // Ensure player can only double down on 9, 10, or 11\n    //         let player_points = hand_points(player_hand).to_u32();\n    //         if player_points < 9 || player_points > 11 {\n    //             // Reject the action\n    //             // Emit error or revert transaction\n    //             return;\n    //         }\n\n    //         // Double the bet (implement bet logic separately)\n    //         // Take exactly one more card\n    //         player_hand.cards[player_hand.card_count.to_u32()] = draw_card(deck, deck.drawn_count);\n    //         deck.drawn_count += 1;\n    //         player_hand.card_count += 1;\n\n    //         // Update the player's hand in storage\n    //         storage.player_hands.at(player).write(player_hand);\n\n    //         // Proceed to dealer's turn\n    //         dealer_play(player);\n    //     }\n\n    //     pub fn hand_points(hand: Hand) -> Field {\n    //     let mut points = 0;\n    //     let mut aces = 0;\n\n    //     for i in 0..hand.card_count.to_u32() {\n    //         let card = hand.cards[i];\n    //         if card.rank == 1 {\n    //             aces += 1;\n    //             points += 11; // Assume Ace as 11 initially\n    //         } else if card.rank >= 10 {\n    //             points += 10;\n    //         } else {\n    //             points += card.rank;\n    //         }\n    //     }\n\n    //     // Adjust for aces if points exceed 21\n    //     while points > 21 && aces > 0 {\n    //         points -= 10; // Convert an Ace from 11 to 1\n    //         aces -= 1;\n    //     }\n\n    //     points\n    // }\n\n}\n"},"82":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n        compute_unique_note_hash,\n    },\n    utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"97":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\n// TODO(9396): Remove.\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// TODO(9396): Remove.\n//unconstrained fn function_selector() -> u32 {\n//    function_selector_opcode()\n//}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert<let N: u32>(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// TODO(9396): Remove.\n//#[oracle(avmOpcodeFunctionSelector)]\n//unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"},"98":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr","source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        header::get_header_at,\n        key_validation_request::get_key_validation_request,\n        logs::{emit_encrypted_event_log, emit_encrypted_note_log},\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log_hash::{EncryptedLogHash, LogHash, NoteLogHash},\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_ENCRYPTED_LOGS_PER_CALL, MAX_KEY_VALIDATION_REQUESTS_PER_CALL,\n        MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    },\n    header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"}}}