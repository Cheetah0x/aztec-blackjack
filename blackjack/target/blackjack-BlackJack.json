{"transpiled":true,"noir_version":"0.36.0+b0cbf84eaf69f77628939184c9b869cfb3e15846-aarch64","name":"BlackJack","functions":[{"name":"dealer_cards","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"cards","type":{"kind":"array","length":10,"type":{"fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}],"kind":"struct","path":"CardNote::CardNote::Card"}}},{"name":"card_count","type":{"kind":"field"}},{"name":"bust","type":{"kind":"boolean"}}],"kind":"struct","path":"CardNote::CardNote::Hand"},"visibility":"public"}},"bytecode":"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","debug_symbols":"7V3Rbtw4EvwXP+eBTbJJdn7lcFgku9mFgSBZJNkDDkH+/eQko5mzxpRdnJmw2Xw5OLdqq7pZnqqSRuLXuz/evf3nr9/uP/z58fPd6399vXv/8fc3X+4/flj+9fXbq7u3n+7fv7//67fT//vOPfwPle/Hf/77zYeHf37+8ubTl7vXlMS9unv34Y/lx+zc8hv+vH//7u515m//fnVH8vIa74AaAmo8UBOAmgjUMFCTgJoM1AA88AAPwkt58Gp7sHN8ONh5Xg8mljNHhxIOv3r5UdajJZ85OIWYfh6cQvKnBz9gpwtgL/5w8AL+htj9BbBHWuee9uZOvsTD0SG6OvacfP55cE7ZPcYeLoqd3P9jfzhDvPoZ+OpnSFc/w/nPFQnlUCSxPP57L0CNvLwmOqCGgBoP1ASgJgI1DNQkoAbgQQR4EAEeMMADBnjAAA8Y4AEDPGCABwzwgAEeMMADBniQAB4kgAcJ4EECeJAAHiSABwngQQJ4kAAeJIAHGeBBBniQAR5kgAcZ4EEGeJABHmSABxngQQZ4UAAeFIAHBeBBAXhQAB4UgAcF4EEBeFAAHhSABwLwQAAeCMADAXggAA8E4IEAPJAneCCHkOEdhZ1EQjGsiSQdT0CFzhzN7A4xktkfjz6bOdnzIYovP4bTgx+wF8XYRS/25eKOZvCkGbzXDD5oBh81g2fN4JNm8Ir1dbkQrhm8ZoUlzQpLmhWWNCssaVZY0qywpFlhSbPC+s45n2UFX9wGfOeTl8NdfA6ONuBv7m2irEzgGHbAx3S47sExn1z38Gfvqub1IomT48HhR6PFSqNipNHgrDRKVhr1VhoNVhqNVhplK40mK41acUbBijMKVpxRtOKMohVnFK04o2jFGUUrzihacUbRijOKVpxRtOKMohVnxFacEQ/0N0rpiCOHR42mgVaUyrqiJPFxo0943XLSqNQbzSkdbmTkJP4Uzfcz+KufIVz9DPHqZ+CrnyFd/QxPfDrw8Vum+fG3TOmpRwnqRQIUPfUwQb2IkCKPFAWkKCJFjBQlpAhhREYYkRFGFIQRBWFEQRhREEYUhBEFYURBGFEQRhSEEQVhhCCMEIQRgjBCEEYIwghBGCEIIwRhhCCMEIAR3jmkiJAijxQFpCgiRYwUJaQoI0UFKUIYQQgjCGEEIYwghBGEMIIQRhDCCEIYcf7lOAsl/Wp4S7xohrvcd9f8+bf0KAF//nVBWsCTZvBeM/igGXzqG3zty6bed/5pU/uyqQ83/7T5NVdffSArjXorjQYrjUYrjbKVRss4jdZuBfk40Kdu7VaQj0986vKxUdl5BV39BoGP4epniFc/A1/9DOnqZ8hXP8MTnw5e1jNEeRzYowBF7JAiQoo8UhSQoogUMVKUkKKMFCGMYIQRCWFEQhiREEYkhBEJYURCGJEQRiSEEQlhREIYkRFGZIQRGWFERhiREUZkhBEZYURGGJERRmSEEQVhREEYURBGFIQRBWFEQRhREEYUhBEFYURBGCEIIwRhhCCMEIQRgjBCEEacv/O73Co7vL56uZfFOyEprG8Rp3ByffWJkCRuvaApPtZDUqRw+NWRmB6b1fN3oLWAL5rBi17w4fw3A7SAJ83gvWbwQTP4qBk8awavWGGDU6ywwSlW2OA0KyxpVljSrLCkWWFJs8KSZoUlzQpLmhWWNCssaVZY0qywXrPCes0K6zUrrNessF6zwnrNCus1K2zo/NNm3Zp0+TFuwPfNee8O34+KC5AN+Jvbg5LXb2AV2QHPKR22Sl1+5NODH8DHl9Lme5FHigJSxF3PNh9ZlEk2s019E0NiDXzue/KeVvBhs6dv7PtPcge8KAbPTjN40gzeawYfNIOPmsH3rbCpuCN4qh8skQ6dSuTNJvXcuRw/2el38H3L8Q74zh1yHXzfclwHn/qW4x3wnV/GqUba1HmkJV4jrS8b8H1fxtkB3/dlnB3wfd8o2QHf942SHfB93yipg8993yjZAd/3pcsd8H3fKNkB37fC7oDXrLBZs8JmzQqbNSts1qywWbPCFs0KWzQrbNGssEWzwhbNCls0K2zRrLBFs8IWzQpbNCusaFZY0aywollhRbPCih6FDfkU/Pbgxd4frocvfnPbqR453u80U63TzrW7+mW2zh823wHfuXbXwXeu3TXwsfOHzXfAd67ddfCda3cdfOfaXQffuXbXwXcux3XwihU2dv6w+Q54xQobO3/YvA6+84fNd8BrVtjOHzbfAa9ZYenmmxb8mpc4xycej9bZqBzWn5YGHjc60mu5q42KkUb9QNtb1Bsd6UXr1UYH2t6i3uhA21vUG41WGh1oewuSfGw0nzR67heXvKIgV//FIa7PA4UYdlB4CYfr4l5OHjr36RwMt27WzE7k9ODvizOSmxtucYZyoKMtzlCuebTFGcrpD7Y4I22+N97iDJWoRlucoVLgaIszVHIdbXHiXJx+F2deIXjG4qS8Lk55/Ka5GGaObx7hTNvNI5yZ+IUjLJsRzuT6jBHKocHALj8eYZz5snmEMwU2j3BmtZeNkOJmhDNRPWeE6xMe7DeKHGfueY4ip9oIZzppHuFMJ80jnOmkeYQznTSPcKaT54yQjyPc+EKe6aR5hDOdNI9wppP9ES5A1xGmzZUanumkeYRxjrB1hDOdvGyEmTcjnOnkGSNc3wodWDZXanimk+YRznTSPMKZTl40wuQ2AS/NdPKMEWY5jnCjyGmmk+cocqiNcKaT5hHOdNI8wjhH2DrCmU6aRzjTyXNGuN4ETRQ2I5zppHmEM500j3Cmk9YR5plO9keY4jHg8XaEM508Y4Rp/SJ8ypvLDHmkdFLKiuPkgsqPJ/fzSBmi2mi00uhIfrza6EiuudroSN622uhIDrTa6Eg+sdZoGcnNVRsdyXNVG7XijIoVZ1SsOKNixRkVK86oWHFGxYozKlackVhxRmLFGYkVZyRWnJFYcUZixRmJFWckVpyRWHFGYsQZsTPijNgZcUbsjDgjdkacEbtopVEjzoidEWfEzogzYmfEGbGz4ozIijMiK86IrDgjurmOLh/0a6MnG4Cfb9Svj/ssx7rTg7+DT12DD2Fd0hD9BnzuGzzlGvjSN3gXj+B3/pgkuANoCYE3nUrffyDCa6cnjxT+BH/7zcguCZ40g/eawQfN4KNm8J3LcR1833K8A75vOd4B37cc74DXrLBBs8IGzQobNCts0Kywt9/Q45LgNSts0Kyw51+vTyK0gj997FDt7uV8/iX4ShutbC/L519VP2Kj3kqjwUqj0UqjbKXRZKXRbKXRMlKjY20cx3EkNzfa4vBQDnS0xRnKNY+2OEM5/dEWZ6h0MtrixLk4/S7OUClwtMUZKrmOtjhDpe3RFmdeIWjcN5p55vjWEaaZtptHODNx4+7lnGZybdw3mtPMl80jjHOErSOcWa1x93JOM1E17l7Oaeaexh17Oc100jzCmU5aR5hnOmke4UwnzSOc6aRx32jOM500jzDOEbaOcKaTxn2jOc900jzCmU6aRzjTSePu5ZxnOmncN5rLTCfNI5zppHmEM5007l7OZaaTxt3Lucx00rhjL5eZTppHONNJ8whnOmke4UwnzSOc6aRx02OWmU6aRzjTSfMIZzppHuFMJ427l7PMdNK4eznLSOmk9lZhGSlDVBsdyelXGx3Jj1cbHck1VxpNbiRvW210JAdabXQkn1htdCQ3V200WmnUiDNKzogzSs6IM0rOiDNKzoozIivOiKw4I7LijMiKM6JopVErzoisOCOy4ozIijMiK87IW3FG3ooz8lackbfijLwVZ+StOCNvxRl5K87IW3FG3oozClacUbDijIIVZxSsOKNgxRkFK84o3FxHL7d7ebr9fmiX27083X6Ps8vtXp5uv2/ZL9q9PN1+47LLbRiYbr8Z2SXBR83gWTP4pBl81gy+czmug+9bjuvguW853gHftxzvgNessKxZYW+/4cwlwWtWWNassKxZYVmzwrJahf22/Os/bz7dv3n7/t3npebhP/7z4fcv9x8//Pznl//+/eO/LAf/Dw==","brillig_names":["dealer_cards"],"assert_messages":{"448":"attempt to add with overflow","512":"attempt to add with overflow","372":"attempt to multiply with overflow","497":"attempt to add with overflow","625":"Array index out of bounds","360":"attempt to add with overflow","421":"Array index out of bounds","485":"Array index out of bounds","351":"Array index out of bounds","412":"attempt to add with overflow","677":"Stack too deep","400":"Array index out of bounds","385":"attempt to add with overflow","571":"attempt to add with overflow","635":"attempt to add with overflow","620":"attempt to add with overflow","480":"attempt to multiply with overflow","544":"Array index out of bounds","608":"Array index out of bounds","535":"attempt to add with overflow","465":"attempt to add with overflow","523":"Array index out of bounds","377":"Array index out of bounds","502":"Array index out of bounds","36":"Not initialized","603":"attempt to multiply with overflow","658":"attempt to add with overflow","588":"attempt to add with overflow","390":"Array index out of bounds","646":"Array index out of bounds"}},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"error_types":{"3469988399892582431":{"error_kind":"fmtstring","item_types":[],"length":20}},"parameters":[{"name":"contract_address","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"error_types":{},"parameters":[{"name":"player","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"],"assert_messages":{"695":"Array index out of bounds","759":"attempt to add with overflow","686":"Array index out of bounds","677":"Array index out of bounds","610":"attempt to add with overflow","415":"attempt to multiply with overflow","351":"Array index out of bounds","741":"Array index out of bounds","863":"attempt to add with overflow","644":"Array index out of bounds","635":"Array index out of bounds","437":"Array index out of bounds","501":"attempt to add with overflow","239":"Initialization hash does not match","364":"Array index out of bounds","626":"Array index out of bounds","812":"attempt to add with overflow","870":"Stack too deep","346":"attempt to multiply with overflow","334":"attempt to add with overflow","846":"Array index out of bounds","712":"attempt to add with overflow","325":"Array index out of bounds","386":"attempt to add with overflow","450":"attempt to add with overflow","517":"Array index out of bounds","828":"Array index out of bounds","246":"Initializer address is not the contract deployer","374":"Array index out of bounds","432":"attempt to add with overflow","557":"attempt to add with overflow","837":"Array index out of bounds","359":"attempt to add with overflow","420":"Array index out of bounds","484":"Array index out of bounds","475":"Array index out of bounds","539":"Array index out of bounds","661":"attempt to add with overflow","466":"Array index out of bounds","399":"attempt to add with overflow","719":"Array index out of bounds"}},{"name":"dealer_hand","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"cards","type":{"kind":"array","length":10,"type":{"fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}],"kind":"struct","path":"CardNote::CardNote::Card"}}},{"name":"card_count","type":{"kind":"field"}},{"name":"bust","type":{"kind":"boolean"}}],"kind":"struct","path":"CardNote::CardNote::Hand"},"visibility":"public"}},"bytecode":"JgAEAQInAASAWQABJgAEAwAmAgQAASYCBAACHxgAAgABgEMkAAAAEQAoAQIEJwIEgEMABSYCBBQGLQQABIADLQQABYAELQQABoAFJAAAAQMtBAACgFctBAADgFg6AIBDABYkAAABDh4CAAACHgIAAAMyOAACAAMABCYCAQECIwIAAAAZAAQmAgQAAzsJAAMeAgoAAiYCAAEDCjgCAwQjAgAAAB8ABCYCBAAFOwkABSYCAAACLAgBAyYCBAsEABABBAEmAwQBAwAoAwIELAwEBSwOAgUAKAUCBSwOAgUAKAUCBSwOAgUAKAUCBSwOAgUAKAUCBSwOAgUAKAUCBSwOAgUAKAUCBSwOAgUAKAUCBSwOAgUAKAUCBSwOAgUAKAUCBSwOAgUsDQMEACgEAgQsDgQDLAgBBAAAAQIBLA4DBCYCBAEDJgIANgUmAgQABiYCBAoHLAwGASIAAABFDDgBBwgjAgAAAOsACCIAAABILA0EBSwIAQQmAgQVCAAQAQgBJgMEAQQAKAQCCCwMCAksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJACgJAgksDgIJLA0ECAAoCAIILA4IBCwIAQgAAAECASwOBAgmAgQDBCYCBA4JJwIEAQAACiYCBAILLAwGASIAAACCDDgBBwwjAgAAAIgADCIAAACFLA0IASYCAQADJSwNCAwmAgQKDgw4AQ4PIwIAAACOAA8mAgQAEDsJABAAKAUCDgA4DgEPLA0PDSwIAQ4mAgQhDwAQAQ8BJgMEAQ4AKA4CD0M6AA0ADwAKACAAJgIEIBAtBAAPgAMtBAAQgAQkAAABFAAoDgIPADgPBhAsDRANHAwEDQ8AKA4CEAA4EAMRLA0RDRwMBA0QBDgQCg0AOA8NEA44DxARIwIAAACpABEmAgQAEjsJABIGOBAJDwQ4DwkRAjgQEQ0AKA4CEAA4EAsRLA0RDxwMBA8QACgOAhEAOBEEEiwNEg8cDAQPDgQ4DgoPADgQDw4OOBAOESMCAAAAugARJgIEABI7CQASJgIEBBAGOA4QEQQ4ERASAjgOEg8cDAANDhwMAA8NBDgBCw8mAgQAEQo4EQsQIwIAAADJABAGOA8LEwo4EwESIwIAAADJABImAgQAFDsJABQmAgQUEQw4DxESIwIAAADOABImAgQAEzsJABMtBAAMgAMnAAQAFYAEJAAAASctCIAFABAAKBACEQA4EQ8SLA4OEgA4DwMMDjgPDA4jAgAAANoADiYCBAAROwkAESYCBBQPDDgMDxEjAgAAAN8AESYCBAASOwkAEgAoEAIPADgPDBEsDg0RLAwQDiwODggAOAEDDA44AQwNIwIAAADpAA0mAgQADjsJAA4sDAwBIgAAAIIsDQQIHAwAAQkAOAUJCi4MAAoACSYCBAoLDDgBCwwjAgAAAPQADCYCBAANOwkADS0EAAiAAycABAALgAQkAAABJy0IgAUACgAoCgILADgLAQwsDgkMADgBAwgOOAEICSMCAAABAAAJJgIEAAs7CQALLA4KBCwMCAEiAAAARQEAgAOABYAHLQCAA4AILQCABIAJCwCACIAHgAojAAAAAQ2ACi0BgAiABi0CgAaACQEAgAgAAoAIAQCACQACgAkiAAABBiUnAAR4AIAEDQAAAIAEgAMjAAAAAROAAycABAAAgAQ8AQAAgAQlJwAEAAKABgcAgASABoAFLQCABIAIJwAEAACACQ0AgAmABYAKFwCACoAKIwAAAAEmgAoDAIAIAAKACAEAgAOACYALLQGAC4AGAQCAA4AIgAstAYALgAcBAIADgAmACy0CgAeACwEAgAOACIALLQKABoALAQCACQACgAkiAAABGCUtAYADgAYLAIAGAAKAByMAAAABK4AHIgAAAS0tAIADgAUiAAABOy0AAAGABQEAAAGABAABAQCAA4AEgAktAIADgAotAIAFgAsLAIAKgAmADCMAAAABOYAMLQGACoAILQKACIALAQCACgACgAoBAIALAAKACyIAAAEyJwEEAAGABSIAAAE7JS0AGMoYyg==","debug_symbols":"7V3tbuJIEHwXfufHdE/3fORVTqdVsptdISGyStiTTlHe/QwXDyxGA8TAurvnTwRhbKqq7VS1Hei32benx18/vsyX359fZ/d/vc0Wz18fVvPnZffs7f1u9vgyXyzmP77s/nrm1j8gbda//nxYrp++rh5eVrN7CNndzZ6W37qH0bluD9/ni6fZfeT3u+Fi57hf7JDLYuB8YLVPvt919zCX1TkeWBw8hY/FwQfcXfz33QzyBbAn7Bd34G+HHd0FsBMU3cMx3QET9as9uTr2GDB+LI4hun3scFHs4H7Hvn4HvPo7+Ku/A139HXj0OzBAf1Qw+GNHBebUHxUeYf+oCGeiWW8TP7FN+sQ2+fxtvPvENofPjIihbMPHag7kS81D2tY8waH6setPVGZM9foxcv/Hrnvo9+rnUTB2Lxg7CcbOgrEHwdijYOxJMPYsFzs5wdgF+yoJ9lUS7Ksk2FdJsK+SYF8lwb5Kgn2VBPsqC/ZVFuyrLNhXWbCvsmBfZcG+yoJ9lQX7Kgv2VRbsq0GwrwbBvhoE+2qY+PEec8Ge9u+qxYnrnvubvOzd/r2fePM8Q7kcBky+jp2o3KAmgu1ttIgH77nF/iYXuLzF4Tc8yQhPNsIzGOEZjfBMRnhmGzyTM8ITjPBEIzyN5KFERngayUPJSB5KRvJQMpKHkpE8lI3koWwkD2UjeSgbyUOZjPA0koeykTyUjeShbCQPZSN5CJyRQATOSCICZyQSgTOSicCRFaJGUhE4I7Goe9EKUSPBqPuNEaJgJRmBlWQEVpIRWElGQFaIWklGYCUZgZVkBFaSEVhJRmglGaGVZIRWkhFaSUZe0TkKYYsj+n2iiioKqVQUMu0TVZSM6hVVlIwg9x9Y6Vwz7BNVlIzqRBUloypR0vRXt0pUUTKqE1WUjOpENflolShZIaromhHkuCUad4ge2jFS2THF+o49Yf8FoZ58qi/G7HvImHn7EU4Mh8Rwqd8zu5x3F2+KoynNqSuOqgSqrTiqUrO24qhK+sqKw6q6E23FUdVRaSuOqi5QW3FUda7aikOtONMtTrtCcEJxQizFSbC7eCNh6+NHS9i67dEStp74TAnTQMLWuZ4gYe4JenZxX8LQ+svRErYucLSErVc7T0KggYStozpFQiwS4sCRAzUJT3DkUJOwdSejJWzdyWgJW3cyWsLWnYyWsHUnp0jIWwkHuTC27mS0hK07GS1h606OS9gBLRKGwZUaTd+V/6ckpCbhWAlbd3KehJEHErbu5AQJkysS5sGVGk1zCf6UhK07GS1h607OkjC4QYOnaVDD9SQs4586CQeOrGkGxBUd2dckbN3JaAlbdzJaQmoSjpWwdSejJWzdySkSlpugAfxAwtadjJawdSejJWzdyVgJNY1NuZqEgbYNHg8lbN3JCRKG8o/wIQ4uM2ga9lL9qh9N017qRMkKUU15vEpUU2quEtWUbatENSXQKlFNObFCFDXNfKkT1ZS5qkSNJCPUNPOlTpSsEDWSjFDTzJc6USPJCDXNfKkTtZKMNM18qRO1kow0zXypE7WSjDTNfKkTtZKMNM18qRO1kow0zXypE7WSjDTNfKkTtZKMNM18qRO1koyQrBC1kozQSjJCK8kIrSQjtJKMVE3aqhK1koy8lWTkb+6j7GIhiqlOlLF83Kdb63YXb8CHSYP3vpTUEw7Ax2mDh1gDn6YN3tEW/JGTKXvXlyl7zwOmedonSObCdOcjhR/gbz+M7JLgQTJ4lAzeSwZPksFP3I7r4Kdtx0fAT9uOj4Cfth0fAS/ZYVmyw7Jkh2XJDsuSHfb2Az0uCV6yw7JYh33vnv3z8DJ/eFw8vXbbrF/8tfy6mj8vP56u/v35/yvd4v8A","brillig_names":["dealer_hand"],"assert_messages":{"243":"Array index out of bounds","141":"Array index out of bounds","205":"Array index out of bounds","30":"Function dealer_hand can only be called statically","222":"Array index out of bounds","24":"Not initialized","168":"attempt to add with overflow","274":"Stack too deep","200":"attempt to multiply with overflow","232":"attempt to add with overflow","255":"attempt to add with overflow","185":"attempt to add with overflow","217":"attempt to add with overflow"}},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"error_types":{"14336010898202591232":{"error_kind":"fmtstring","item_types":[],"length":16}},"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"],"assert_messages":{"957":"attempt to add with overflow","878":"Array index out of bounds","1902":"Array index out of bounds","1256":"attempt to add with overflow","1512":"attempt to add with overflow","1768":"attempt to add with overflow","2079":"attempt to add with overflow","586":"Not initialized","1653":"attempt to add with overflow","1074":"Array index out of bounds","2165":"attempt to add with overflow","873":"attempt to multiply with overflow","1641":"Array index out of bounds","2153":"Array index out of bounds","1373":"Array index out of bounds","1495":"attempt to add with overflow","1751":"Array index out of bounds","1806":"Array index out of bounds","1160":"attempt to add with overflow","1928":"attempt to add with overflow","1459":"attempt to add with overflow","1069":"attempt to add with overflow","2026":"attempt to add with overflow","1447":"Array index out of bounds","1057":"Array index out of bounds","923":"Array index out of bounds","1368":"attempt to add with overflow","1356":"Array index out of bounds","1143":"attempt to add with overflow","1911":"Array index out of bounds","1631":"Array index out of bounds","1052":"attempt to multiply with overflow","473":"Function dealer_hand can only be called statically","1107":"attempt to add with overflow","1095":"Array index out of bounds","1351":"attempt to multiply with overflow","1406":"attempt to add with overflow","1784":"Array index out of bounds","949":"Array index out of bounds","1394":"Array index out of bounds","1717":"attempt to add with overflow","2095":"Array index out of bounds","102":"attempt to add with overflow","1248":"Array index out of bounds","1437":"Array index out of bounds","1626":"attempt to add with overflow","1559":"attempt to add with overflow","468":"Not initialized","913":"attempt to add with overflow","901":"Array index out of bounds","1468":"Array index out of bounds","944":"attempt to multiply with overflow","932":"attempt to add with overflow","2145":"Array index out of bounds","1243":"attempt to multiply with overflow","1432":"attempt to add with overflow","1877":"attempt to add with overflow","1944":"Array index out of bounds","1207":"attempt to add with overflow","1116":"Array index out of bounds","2140":"attempt to add with overflow","336":"Initialization hash does not match","1037":"attempt to add with overflow","1549":"Array index out of bounds","891":"Array index out of bounds","1336":"attempt to add with overflow","1592":"Array index out of bounds","2104":"Array index out of bounds","1824":"attempt to add with overflow","343":"Initializer address is not the contract deployer","1544":"attempt to add with overflow","1733":"Array index out of bounds","1666":"attempt to add with overflow","1020":"attempt to add with overflow","1532":"Array index out of bounds","886":"attempt to add with overflow","1197":"Array index out of bounds","1319":"attempt to add with overflow","1953":"Array index out of bounds","984":"attempt to add with overflow","2008":"Array index out of bounds","1618":"Array index out of bounds","527":"Function view_deck can only be called statically","972":"Array index out of bounds","2130":"attempt to add with overflow","1283":"attempt to add with overflow","2173":"Stack too deep","1271":"Array index out of bounds","1527":"attempt to multiply with overflow","1582":"attempt to add with overflow","1192":"attempt to add with overflow","1704":"Array index out of bounds","1570":"Array index out of bounds","1893":"Array index out of bounds","1180":"Array index out of bounds","1424":"Array index out of bounds","1613":"attempt to multiply with overflow","522":"Not initialized","2113":"Array index out of bounds","1601":"attempt to add with overflow","1979":"attempt to add with overflow","1699":"attempt to add with overflow","1175":"attempt to multiply with overflow","1687":"Array index out of bounds","1230":"attempt to add with overflow","1419":"attempt to multiply with overflow","1742":"Array index out of bounds","962":"Array index out of bounds","1218":"Array index out of bounds","1084":"attempt to add with overflow","1986":"Array index out of bounds","1261":"Array index out of bounds","1962":"Array index out of bounds","1383":"attempt to add with overflow","993":"Array index out of bounds","1682":"attempt to multiply with overflow","1292":"Array index out of bounds"}},{"name":"view_deck","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"error_types":{},"parameters":[],"return_type":{"abi_type":{"fields":[{"name":"cards","type":{"kind":"array","length":52,"type":{"fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}],"kind":"struct","path":"CardNote::CardNote::Card"}}}],"kind":"struct","path":"CardNote::CardNote::Deck"},"visibility":"public"}},"bytecode":"JgAEAQInAASAqwABJgAEAwAmAgQAASYCBAACHxgAAgABgEMkAAAADwAoAQICJwIEgEMAAyYCBGgELQQAAoADLQQAA4AELQQABIAFJAAAANk6AIBDAGgkAAAA5B4CAAACHgIAAAMyOAACAAMABCYCAQECIwIAAAAXAAQmAgQAAzsJAAMeAgoAAiYCAAEDCjgCAwQjAgAAAB0ABCYCBAAFOwkABSYCAAACLAgBBCYCBDUFABABBQEmAwQBBAAoBAIFJgIENAYAOAYFBiwMBQcMOAcGCBYMCAgjAgAAACwACCwOAgcAKAcCByIAAAAmLA0EBQAoBQIFLA4FBCwIAQUAAAECASwOBAUmAgQABCYCBAEGJgIENAcsDAQBIgAAADcMOAEHCCMCAAAAwQAIIgAAADosDQUDLAgBBSYCBGkIABABCAEmAwQBBQAoBQIIJgIEaAkAOAkICSYCBAIKLAwIDAw4DAkNFgwNDSMCAAAATQANLAwMCywOAgsAKAsCCywOAgsAOAwKDCIAAABELA0FCAAoCAIILA4IBSwIAQgAAAECASwOBQgmAgQOAicCBAEAAAUmAgQDCSYCBAIKLAwEASIAAABZDDgBBwsjAgAAAF4ACyIAAABcLA0IASUsDQgLJgIENA0MOAENDiMCAAAAZAAOJgIEAA87CQAPACgDAg0AOA0BDiwNDgwsCAENJgIEIQ4AEAEOASYDBAENACgNAg5DOgAMAA4ABQAgACYCBCAPLQQADoADLQQAD4AEJAAAAOoAKA0CDgA4DgQPLA0PDBwMBAwOACgNAg8AOA8GECwNEAwcDAQMDwQ4DwUMADgODA8OOA4PECMCAAAAfwAQJgIEABE7CQARBjgPAg4EOA4CEAI4DxAMACgNAg8AOA8KECwNEA4cDAQODwAoDQIQADgQCREsDREOHAwEDg0EOA0FDgA4Dw4NDjgPDRAjAgAAAJAAECYCBAAROwkAESYCBAQPBjgNDxAEOBAPEQI4DREOHAwADA0cDAAODAQ4AQoOJgIEABAKOBAKDyMCAAAAnwAPBjgOChIKOBIBESMCAAAAnwARJgIEABM7CQATJgIEaBAMOA4QESMCAAAApAARJgIEABI7CQASLQQAC4ADJwAEAGmABCQAAAD9LQiABQAPACgPAhAAOBAOESwODREAOA4GCw44DgsNIwIAAACwAA0mAgQAEDsJABAmAgRoDgw4Cw4QIwIAAAC1ABAmAgQAETsJABEAKA8CDgA4DgsQLA4MECwMDw0sDg0IADgBBgsOOAELDCMCAAAAvwAMJgIEAA07CQANLAwLASIAAABZLA0FCBwMAAEJADgDCQouDAAKAAkmAgQ0Cww4AQsMIwIAAADKAAwmAgQADTsJAA0tBAAIgAMnAAQANYAEJAAAAP0tCIAFAAoAKAoCCwA4CwEMLA4JDAA4AQYIDjgBCAkjAgAAANYACSYCBAALOwkACywOCgUsDAgBIgAAADcBAIADgAWABy0AgAOACC0AgASACQsAgAiAB4AKIwAAAADjgAotAYAIgAYtAoAGgAkBAIAIAAKACAEAgAkAAoAJIgAAANwlJwAEeACABA0AAACABIADIwAAAADpgAMnAAQAAIAEPAEAAIAEJScABAACgAYHAIAEgAaABS0AgASACCcABAAAgAkNAIAJgAWAChcAgAqACiMAAAAA/IAKAwCACAACgAgBAIADgAmACy0BgAuABgEAgAOACIALLQGAC4AHAQCAA4AJgAstAoAHgAsBAIADgAiACy0CgAaACwEAgAkAAoAJIgAAAO4lLQGAA4AGCwCABgACgAcjAAAAAQGAByIAAAEDLQCAA4AFIgAAAREtAAABgAUBAAABgAQAAQEAgAOABIAJLQCAA4AKLQCABYALCwCACoAJgAwjAAAAAQ+ADC0BgAqACC0CgAiACwEAgAoAAoAKAQCACwACgAsiAAABCCcBBAABgAUiAAABESUtABjKGMo=","debug_symbols":"7V3tbtswDHwX/+4PUaK++irDMKRbNwQI0qHNBgxF331OV8lZHMhOlQYWyT9DstLO3dEu79Qkeu6+3d/9+vFlvf3+8NTdfnruNg9fV7v1w7Z/9vxy0909rjeb9Y8vh//dqf0/4F7rn36utvunT7vV4667BRfVTXe//dY/9Er1Z/i+3tx3t96+3IyLlbKpWGmbi8HGE9UmmHTq/mHM1dGfKHYG3VuxM04fFn++6cBfAHvQqbgHf0Xs4QLYEbLubkp30AFTtUFVxu6d9m/F3nl1jD1eFDuo/7H3r6DVh78CfPgr6A9/BVP9ChYgXRUWzNRVoWNIV4XRcHRVaDwTzf4Y+45j3DuO8e84JrzjmNN3RtAmHRPQTvQcMBeDC0PPA5zqn1XpRrVWh3L/rLbpl13/0Bz1z6iGsUPD2HXD2E3D2LFh7LZh7K5h7L5h7KFh7A3PVWx4rmLDcxUbnqvY8FzFhucqNjxXseG5ig3PVWx4rmLDc9Uu/F71MWMPxytoduHXTEwLutao43Uee/VrBmO+DCyaCezo0hqVRT+c2uuT62s+5BXUOBSbPU+nmPAEJjw1E56GCU9kwtMy4emY8PRMeAYmPJn4Ic/ED3kmfsgz8UOeiR/yyIQnEz/kmfghz8QPeSZ+yDPxQ4GJHwpM/FBg4ocCofsT3IDDm/95RkL9hJD7CRGPeCKTfhLyfRDTH4dAK3fEk5DvK/Ik5PuKPAn5viJPSnOlwBMUIeNXJkrI+ZWJUrIKRaKE1sIg+oGoPyB66sRhePcDqPKJDer0oRuDZgKFjia9VUJHO7xVQrtTMFRIZ7YqxsPi1+agNGe5zSHlPqk1h5RlptYcUj6fWnNIhRNqzSGVqIg1B0ilQGrNIZVcqTWHVNqm1hxZIZjRHOdzcwIcFr9KiCJhrYSStqsllEx8poRhJKEk1xkSxkTQ2IMTJwklX1ZLKCmwVkItWe08CQFHEkqimiOhzhLq0UTWknvmTGRXklDSSbWEKBLWSijppFpCSSfVEko6mSOhHSQc+0JJJ9USSjqpldBIOpmWsAeaJXSjlRoj6aRaQkkn1RJKOjlPQm9HEqJIOC1hyLsQ2DhaqTGSTqollHRSLaGkk7MkdGoU8IykkxkS5q9Z7CUcT2RJJ3MmsilIiJJOqiWUdFItoaSTagklnVRLiCLhDAnzH0EdmJGEkk6qJZR0Ui2hpJNqCSWdTEvocAh4diyhpJMZErr8RnjnR8sMllI6KXzJD1hKGaJIlMnXNoGl5MeLRJELUUretkiUkgMtEqXkE4tEKbm5IlFKnqtElNL2NWWiXJwRpQ1sykS5OCNKW9iUiXJxRpQ2sSkT5eKMKG1jUybKxRlR2simTJSLM6K0lU2ZKBdnRGkzmzJRLs6I0nY2ZaJcnBGlDW3KRLk4I0pb2pSJcnFGlDa1KRPl4owCciHKxRkFLs4ocHFGgYszIrWXWIlo5OKM4tXnqFXDu8F0mCCq88d9+lp1WPwKHhcN3pjcUoN6BN4uGzz4Eni3bPAKB/ATN1M0KrUpGmNHTP2yb5BoM9ODjxQm8KFl8LFd8Pr6m4ZdEjy0DF63DH7h47gMftnjeAL8ssfxBPhlj+MJ8A1PWK0anrBatTxhoeUJCy1PWGh5wkLLE/b6W01cCvxL/+z36nG9utvcP/XH7H/4a/t1t37Yvj3d/fn57yd98V8=","brillig_names":["view_deck"],"assert_messages":{"22":"Not initialized","163":"Array index out of bounds","180":"Array index out of bounds","126":"attempt to add with overflow","158":"attempt to multiply with overflow","190":"attempt to add with overflow","213":"attempt to add with overflow","232":"Stack too deep","143":"attempt to add with overflow","28":"Function view_deck can only be called statically","201":"Array index out of bounds","175":"attempt to add with overflow","99":"Array index out of bounds"}}],"outputs":{"globals":{"notes":[{"fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"fields":[{"name":"value","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"owner","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}},{"name":"randomness","value":{"fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}],"kind":"struct"}}],"kind":"struct"}],"kind":"tuple"}],"storage":[{"fields":[{"name":"contract_name","value":{"kind":"string","value":"BlackJack"}},{"name":"fields","value":{"fields":[{"name":"card_deck","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}],"kind":"struct"}},{"name":"player_hands","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000035"}}],"kind":"struct"}},{"name":"dealer_hand","value":{"fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000036"}}],"kind":"struct"}}],"kind":"struct"}}],"kind":"struct"}]},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BlackJack::dealer_hand_parameters"}},{"name":"return_type","type":{"fields":[{"name":"cards","type":{"kind":"array","length":10,"type":{"fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}],"kind":"struct","path":"CardNote::CardNote::Card"}}},{"name":"card_count","type":{"kind":"field"}},{"name":"bust","type":{"kind":"boolean"}}],"kind":"struct","path":"CardNote::CardNote::Hand"}}],"kind":"struct","path":"BlackJack::dealer_hand_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"player","type":{"fields":[{"name":"inner","type":{"kind":"field"}}],"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress"}}],"kind":"struct","path":"BlackJack::constructor_parameters"}}],"kind":"struct","path":"BlackJack::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BlackJack::dealer_cards_parameters"}},{"name":"return_type","type":{"fields":[{"name":"cards","type":{"kind":"array","length":10,"type":{"fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}],"kind":"struct","path":"CardNote::CardNote::Card"}}},{"name":"card_count","type":{"kind":"field"}},{"name":"bust","type":{"kind":"boolean"}}],"kind":"struct","path":"CardNote::CardNote::Hand"}}],"kind":"struct","path":"BlackJack::dealer_cards_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"BlackJack::view_deck_parameters"}},{"name":"return_type","type":{"fields":[{"name":"cards","type":{"kind":"array","length":52,"type":{"fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}],"kind":"struct","path":"CardNote::CardNote::Card"}}}],"kind":"struct","path":"CardNote::CardNote::Deck"}}],"kind":"struct","path":"BlackJack::view_deck_abi"}]}},"file_map":{"119":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr","source":"use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n"},"124":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr","source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"},"132":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"},"159":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/initializer.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"160":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/hash.nr","source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n"},"165":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr","source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n"},"181":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr","source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicMutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"},"223":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr","source":"use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n"},"232":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"24":{"path":"std/embedded_curve_ops.nr","source":"use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"},"25":{"path":"std/field/bn254.nr","source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"26":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"},"29":{"path":"std/hash/mod.nr","source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"},"3":{"path":"std/array/mod.nr","source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a: T, b: T| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        unsafe {\n            // Safety: `sorted` array is checked to be:\n            //   a. a permutation of `input`'s elements\n            //   b. satisfying the predicate `ordering`\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n"},"303":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"305":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr","source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n"},"308":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr","source":"use crate::meta::{derive_deserialize, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for U128 {\n    fn empty() -> Self {\n        U128::from_integer(0)\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for U128 {\n    fn to_field(self) -> Field {\n        self.to_integer()\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for U128 {\n    fn from_field(value: Field) -> Self {\n        U128::from_integer(value)\n    }\n}\n\n// docs:start:serialize\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n"},"313":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n    utils,\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    ec::{pow, sqrt},\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"320":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr","source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::default::Default;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"},"322":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedEncryptedLogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__VK,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    proof::verification_key::VerificationKey,\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"323":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr","source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n"},"34":{"path":"std/hash/poseidon2.nr","source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"340":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/value-note/src/value_note.nr","source":"use dep::aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator, traits::Serialize,\n    },\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n"},"58":{"path":"std/option.nr","source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"59":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"72":{"path":"/Users/niallcheetham/dev/aztec/blackjack/blackjack/src/CardNote.nr","source":"use dep::aztec::prelude::{NoteGetterOptions, NoteViewerOptions, PrivateContext};\n\nuse dep::aztec::{\n    context::PublicContext,\n    encrypted_logs::encrypted_note_emission::encode_and_encrypt_note,\n    keys::getters::get_public_keys,\n    macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    },\n    protocol_types::{\n        address::AztecAddress,\n        constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n        traits::{FromField, Serialize, ToField},\n    },\n    state_vars::PrivateSet,\n};\nuse dep::value_note::value_note::ValueNote;\n\n//leave this for now, just the note for the card, going to be done in public first\n\n// #[note]\n// #[derive(Serialize)]\n// pub struct Card {\n//     suit: u8, //representing the suit\n//     value: u8, //representing the value 1-14\n//     // owner: AztecAddress,\n// }\n\n// impl FromField for Card {\n//     fn from_field(field: Field) -> Card {\n//         let value_bytes: [u8; 32] = field.to_le_bytes();\n//         let suit = ((value_bytes[0] as u32) + (value_bytes[1] as u32) * 256) % 4;\n//         let value = ((value_bytes[2] as u32) + (value_bytes[3] as u32) * 256) % 14;\n//         let header = NoteHeader::empty();\n//         Card { suit: suit as u8, value: value as u8, header }\n//     }\n// }\n\n// // impl NullifiableNote for Card {\n\n// //     fn compute_nullifier(\n// //         self,\n// //         context: &mut PrivateContext,\n// //         note_hash_for_nullify: Field,\n// //     ) -> Field {\n// //         let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n// //         let secret = context.request_nsk_app(owner_npk_m_hash);\n// //         poseidon2_hash_with_separator(\n// //             [note_hash_for_nullify, secret],\n// //             GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n// //         )\n// //     }\n\n// //     unconstrained fn compute_nullifier_without_context(self) -> Field {\n// //         let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n// //         let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n// //         let secret = get_nsk_app(owner_npk_m_hash);\n// //         poseidon2_hash_with_separator(\n// //             [note_hash_for_nullify, secret],\n// //             GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n// //         )\n// //     }\n// // }\n\n// impl ToField for Card {\n//     fn to_field(self) -> Field {\n//         //equivalent to bit shifting 2^16\n//         self.suit as Field + self.value as Field * 65536\n//     }\n// }\n\n// impl Eq for Card {\n//     fn eq(self, other: Self) -> bool {\n//         (self.suit == other.suit) & (self.value == other.value)\n//     }\n// }\n// impl Serialize<2> for Card {\n//     fn serialize(self) -> [Field; 2] {\n//         [self.suit as Field, self.value as Field]\n//     }\n// }\n\n// CardNote.nr\npub mod CardNote {\n    use dep::aztec::protocol_types::{\n        address::AztecAddress,\n        constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n        traits::{Deserialize, FromField, Serialize, ToField},\n    };\n    use std::hash::poseidon2;\n\n    //-------------------------------CARD-----------------------------------\n\n    #[derive(Serialize)]\n    #[derive(Deserialize)]\n    pub struct Card {\n        pub rank: Field,\n        pub suit: Field,\n    }\n\n    impl FromField for Card {\n        fn from_field(field: Field) -> Card {\n            let value_bytes: [u8; 32] = field.to_le_bytes();\n            let rank = ((value_bytes[0] as u32) + (value_bytes[1] as u32) * 256) % 14;\n            let suit = ((value_bytes[2] as u32) + (value_bytes[3] as u32) * 256) % 4;\n            Card { rank: rank as Field, suit: suit as Field }\n        }\n    }\n\n    impl ToField for Card {\n        fn to_field(self) -> Field {\n            self.rank as Field + self.suit as Field * 65536\n        }\n    }\n\n    //-------------------------------HAND-----------------------------------\n\n    pub struct Hand {\n        pub cards: [Card; 10],\n        pub card_count: Field,\n        pub bust: bool,\n    }\n\n    impl Serialize<10> for Hand {\n        fn serialize(self) -> [Field; 10] {\n            let mut fields = [Field::empty(); 10];\n            for i in 0..10 {\n                fields[i] = self.cards[i].to_field();\n            }\n            fields\n        }\n    }\n\n    impl Deserialize<10> for Hand {\n        fn deserialize(fields: [Field; 10]) -> Self {\n            let cards = fields.map(|field| Card::from_field(field));\n            Hand { cards, card_count: 0, bust: false }\n        }\n    }\n\n    impl ToField for Hand {\n        fn to_field(self) -> Field {\n            // Serialize the cards array into fields\n            let mut card_fields = [Field::empty(); 10];\n            for i in 0..10 {\n                card_fields[i] = self.cards[i].to_field();\n            }\n\n            // Hash the serialized data\n            poseidon2::Poseidon2::hash(card_fields, 10)\n        }\n    }\n\n    //-------------------------------DECK-----------------------------------\n    pub struct Deck {\n        pub cards: [Card; 52],\n    }\n\n    impl Serialize<52> for Deck {  // Implement Serialize with explicit size\n        fn serialize(self) -> [Field; 52] {\n            let mut fields = [Field::empty(); 52];\n            for i in 0..52 {\n                fields[i] = self.cards[i].to_field();\n            }\n            fields\n        }\n    }\n\n    impl Deserialize<52> for Deck {\n        fn deserialize(fields: [Field; 52]) -> Self {\n            let cards = fields.map(|field| Card::from_field(field));\n            Deck { cards }\n        }\n    }\n\n    impl Deck {\n        pub fn new(storage_slot: Field) -> Self {\n            let cards = [Card { rank: 0, suit: 0 }; 52];\n            Deck { cards }\n        }\n    }\n\n    impl ToField for Deck {\n        fn to_field(self) -> Field {\n            let mut card_fields = [Field::empty(); 52];\n            for i in 0..52 {\n                card_fields[i] = self.cards[i].to_field();\n            }\n            // Hash all card fields into a single Field\n            poseidon2::Poseidon2::hash(card_fields, 52)\n        }\n    }\n    //-------------------------------CARD FUNCTIONS-----------------------------------\n\n    pub fn new(rank: Field, suit: Field) -> Card {\n        Card { rank, suit }\n    }\n\n    pub fn card_points(card: Card) -> Field {\n        if (card.rank as u8 > 1) & (card.rank as u8 <= 10) {\n            card.rank\n        } else if card.rank == 1 {\n            11 // Ace as 11 initially\n        } else {\n            10 //Face cards (J,Q,K)\n        }\n    }\n\n    pub fn new_hand() -> Hand {\n        Hand { cards: [Card { rank: 0, suit: 0 }; 10], card_count: 0, bust: false }\n    }\n\n    pub fn hand_points(hand: Hand) -> Field {\n        let mut points = 0;\n        let mut aces = 0;\n\n        for i in 0..hand.card_count as u8 {\n            let card_points = card_points(hand.cards[i]);\n            if card_points == 1 {\n                aces += 1;\n            }\n            points += card_points;\n        }\n\n        for _ in 0..aces {\n            if points as u8 > 21 {\n                points -= 10; //convert ace from 11 to 1 if needed\n                aces -= 1;\n            }\n        }\n        points\n    }\n\n    pub fn check_bust(hand: Hand) -> bool {\n        hand_points(hand) as u8 > 21\n    }\n\n    pub fn generate_deck() -> Deck {\n        let mut deck: Deck = Deck { cards: [Card { rank: 0, suit: 0 }; 52] };\n        let mut index = 0;\n        for suit in 1..=4 {\n            for rank in 1..=13 {\n                deck.cards[index] = new(rank as Field, suit as Field);\n                index += 1;\n            }\n        }\n        deck\n    }\n\n    pub fn draw_card(deck: Deck, index: Field) -> Card {\n        deck.cards[index as u8]\n    }\n}\n"},"75":{"path":"/Users/niallcheetham/dev/aztec/blackjack/blackjack/src/main.nr","source":"//functionality that i need:\n\n//make it super simple to start similar to kits\n\n// Player hits/stands to beat dealer's hand by getting as close to 21 as possible.\n\n// Dealer must hit on and up to 16 and stand on 17.\n\n// Player can only double down on 9, 10, or 11.\n\n// Player can either double down or split, player cannot split then double down and vice versa.\n\n// Player cannot split then split again or double down more than once.\n\n// Player who splits Aces can receive only one more additional card on a hand.\n\n// Player can get insurance if dealer might have a BlackJack.\n\n// Aces are high unless card total is already greater than 11.\n\n// Blackjack payout is 3:2.\n\n// No surrender.\n\n//some finds here\n//i had to use my own serialisation and deserialisation for the deck, default ones were not working\n\n\n\nmod CardNote;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract BlackJack {\n\n    use crate::CardNote::CardNote::{\n        Card, check_bust, Deck, draw_card, generate_deck, Hand, hand_points, new_hand,\n    };\n    use dep::aztec::{\n        context::PublicContext,\n        macros::{functions::{initializer, private, public, view}, storage::storage},\n        prelude::{AztecAddress, Map, PrivateMutable, PublicImmutable, PublicMutable},\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        card_deck: PublicMutable<Deck, Context>,\n        player_hands: Map<AztecAddress, PublicMutable<Hand, Context>, Context>,\n        dealer_hand: PublicMutable<Hand, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(player: AztecAddress) {\n        let mut deck: Deck = generate_deck();\n        storage.card_deck.write(deck);\n    }\n\n    #[public]\n    #[view]\n    fn dealer_hand() -> Hand {\n        storage.dealer_hand.read()\n    }\n\n    #[public]\n    #[view]\n    fn view_deck() -> Deck {\n        storage.card_deck.read()\n    }\n\n    #[public]\n    fn dealer_cards() -> Hand {{\n        let mut dealer_hand: Hand = new_hand();\n        dealer_hand.cards[0] = draw_card(storage.card_deck.read(), 0);\n        dealer_hand.cards[1] = draw_card(storage.card_deck.read(), 1);\n        storage.dealer_hand.write(dealer_hand);\n        dealer_hand\n    }}\n\n    // #[public]\n    // fn play_game(player: AztecAddress) -> bool {\n    //     // Initialize deck if not already initialized\n    //     let mut deck = storage.card_deck.read();\n\n    //     // Initialize hands\n    //     let mut player_hand: Hand = new_hand();\n    //     let mut dealer_hand: Hand = new_hand();\n    //     let mut current_index = 0;\n\n    //     // Draw initial cards for player and dealer\n    //     player_hand.cards[0] = draw_card(deck, current_index);\n    //     current_index += 1;\n    //     player_hand.cards[1] = draw_card(deck, current_index);\n    //     current_index += 1;\n    //     player_hand.card_count = 2;\n\n    //     dealer_hand.cards[0] = draw_card(deck, current_index);\n    //     current_index += 1;\n    //     dealer_hand.cards[1] = draw_card(deck, current_index);\n    //     current_index += 1;\n    //     dealer_hand.card_count = 2;\n\n    //     // Update storage\n    //     storage.player_hands.at(player).write(player_hand);\n    //     storage.dealer_hand.write(dealer_hand);\n\n    //     let player_points = hand_points(player_hand);\n    //     let dealer_points = hand_points(dealer_hand);\n\n    //     if (player_points as u8 > dealer_points as u8) & !check_bust(player_hand) {\n    //         // Player wins\n    //         true\n    //     } else {\n    //         // Dealer wins\n    //         false\n    //     }\n    // }\n\n}\n"},"82":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/note/utils.nr","source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n        compute_unique_note_hash,\n    },\n    utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n"},"97":{"path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\n// TODO(9396): Remove.\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// TODO(9396): Remove.\n//unconstrained fn function_selector() -> u32 {\n//    function_selector_opcode()\n//}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert<let N: u32>(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// TODO(9396): Remove.\n//#[oracle(avmOpcodeFunctionSelector)]\n//unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"}}}