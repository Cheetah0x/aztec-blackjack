{"noir_version":"0.36.0+b0cbf84eaf69f77628939184c9b869cfb3e15846-aarch64","name":"BlackJack","functions":[{"name":"constructor","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"player","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"databus"},"error_types":{}},"bytecode":"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","debug_symbols":"7V3Rbts6DP2XPPdBpCiJ6q9cXAxp1w0BgnRouwtcFP33KV4lK7UTNYiTqLT2MNQto/CcY8uHtGW/Lr4/3P3++W21+fH4vLj953WxfrxfvqweN2HrdQG6+93zr+Vmu/n8snx6WdyC9epm8bD5Hn50Sr3dLH6s1g+LW2febgbByJreg5GNTcFg1Ui0NmDeo7VhLkRD+BcHDz9iH68Rx+KZbQz3yvTRNDo4+jS24zz435sFUGNmDzOmMbOHGduY2cOMO5kZUhixkrKQgj13X8Dn/gJ/urZoIp+InGlr/Ei0oxjsuOceNG6zQXXpbKDPxu5kMzKyQowjE/VpaBiLJnCJdvA22ydVhxRmgxRng1TPBinNBqmZDVI7G6RuNkh5Nkj9XJBqQR6JVEyaCGGAVJBHKiAV5JEKSAV5pAJSmg1SQR6pgFSQRyogFeSRCkgFeaQCUkEe6TBSEuSRbN++szRwgyTIIxWQCvJIBaSCPFIBKc0GqSCPVEAqyCMVkArySAWkgjxSAakgj3QYqRHkkZjiRVpiN3CDRpBHKiAV5JEKSAV5pAJSmg1SQR6pgFSQRyogFeSRCkgFeaQCUkEe6TBSe2mP5NnFkZUqQnWK49CcDT0OFRDTXXLoKYu2I9HWxEQ4v0UOxiCCsjrdUacs+YzG0UwoSQREGenH34BnoQlUt0DYBKpbIN0E+pRATvcCsSsJNN09xpaaQHULZAQJBL1Aeof0MYHA9NOQ9VCKvqJEtklUu0Suaoks6SSRdwWJ0KeZC73TWbQeidYAUX4dSpadGqQuq8BNotol8k2iyiVydfcUmkRBorq7Ck2iIFHdfYUmUZCo7s5CkyhIRE2i2iWqu7vQJAoS1d1daBIFiVp3oXqJWneheolad6F2ibh1F6qXqHUXqpeodRc+K9G1rhdx6y5ULxHJkUgrFa+6hkunpiDRNUkX1C/4OqQL6gBoTE9T1Gi4QHqYgCIvSBnlSEXG+3kOTUeioBr9nCR6YxKJ2Z6Iow9/tBEi+Yxv2/EtqOA+I9+oFMRghXQC34Kq53PyDZASAe0/TBJeUH17ThJDdI9RH95pQfcYKTsRvjMuqFz9IowLqj6rYdzo5A1N9gDqo2dxL6julCcONXGmFyc9jjJwcILf9JIqU3HiSKpgwdteHF8QJ7SKY9uYKGunjYqjXeJQM+g8eEuipAr2jCSyjxWV9kMSJZWlVyNRUq15LRIDksbiBCxKKiCvx6KkovB6LEqq3q7HIjUWJ2BRUj10PRZb4TIFi1IrF1u6myJMZgmjyp4ANMqiAR9rcxM6AAMWpZYul2VRau1yURZBau1yWRal1i4Ts4jprY4GrR2wKLV2uSyLUmuXy7JIjcUJWJRau0zMonXRdRsHBYvu+tvdneWBRQephU7FlLeq6FOUMyTK2eBplLcS6gyU+4jROYAB5a3eujTldb/nHPrVKCGPHca75Kt+nUIp+XYZ5XPtwpSIZuMG+2+7jDIFi3RFFsHtsNjlM4Gp14keDOgL+WB/N00QSheir7i+B6Z4ObpUaiYwyTqdLZEId8B2XzGBKTRpKRka9AU+jfMmnetB7cwJXUK+soSmeCn4tAlNYBJMqhTQOFc6BEBneykNE8LaEtK1JUS1JWSm2Kl1nxAPZpYJXujMEEFw9tCBPUdNP++afAHk9s7dkXO7wv7krozJw7vk3VdNPmzcPa3W69XPb+vH++XL6nHzvP2w2v433nUx6anXxsLAuvDxH/FHf2S8ajv8ETj+I3jkR8IWdLyNz3Aqla2g9M5So5FKK50CHGAe2u1u5x2eTh8+rSJx9HHd4J6G9XHDY2pcfVy7vKc5O9nw7vThOR7pLiuJ3ofn8w7vTx6e02TC9HHP2dNMOW74aGZ4d/nR3kP4uOFdlJYH5CBOOLz/cFiFDTwwNYBKD8wBxZ87YoDSghOwhaVarEw8FbFyu0tO3sLWf8un1fJu/bCd+7d//L25j6eCsPny/6+/fwnBfwA=","brillig_names":["get_contract_instance_internal","decompose_hint","lte_hint","directive_integer_quotient","directive_invert"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"3469988399892582431":{"error_kind":"fmtstring","length":20,"item_types":[]}}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"begin_game","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"player","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["begin_game"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"14336010898202591232":{"error_kind":"fmtstring","length":16,"item_types":[]}}},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"]},{"name":"player_hand","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"player","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"CardNote::CardNote::Hand","fields":[{"name":"cards","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":6,"type":{"kind":"struct","path":"CardNote::CardNote::Card","fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}]}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"bust","type":{"kind":"boolean"}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1cS28jWRW+5bjs2Iljx3anHzOgQmKQeDVOOv3QgJi0ZkCMGA3d0xIbkJAndk9bnY4jx5nuzMqwBAmWLEBILJEQLFmwhb/ASAiNBOz4FbjSdeLPn0/d2OW6iWeUKzn1uOee1z33nHMfFc+8LGvDnxfd+9FVnrHIu53o2pivbKaIq7EEPK7CfWb4C+uykWy54S8//C0Pf4Xhrzj8rUCbEujkBEHWopC1hIRKUdtXFdyvwX05ur7b7Qed/U6/09zrfNRuIfhX4X4run73aH+33+nuBwd7zeN27ydPmvutYLe5H3T3946D99vD+729dis47Df7nfD+GDH+Eu6/FV0f9bu95gft4HBvyEkj2B/+HTbrPm+3bgZYdxg8Ozrsh4h7/eBxr/ss2LyJuP8D99ej6/1er3k8FK/VfhF0j/pB93Hwfvdov3WIDT14EK01+/32s4N+0O8GzVYreN7pPwm6H7Z7j4eMYdvqHG0/Bw/V6HpwdPgkntMvw8MXJqk9O9rrdw6G3RBLEhU2k45en0PON5IS/d4cRB/M0fZHSRn+YA6iL5IS/WnShj9P2vA3c4j5p6RE/5a04T/m4HYlk7ztK5mEDH8xacOvJ2347TnEfABtJWY96jd3nw5bdoNWu31wGoI+ikAL0bO0DOvD8LYTPTfmK5sFwJs2/nuN21sFM15S5v9WwYzCviv9CE4H+Bv5CM+bgxF+liUspegZzUnahKlNFdpgumQiHNxWaIh8vgP57jW2twV/zgH+YdmVPHFpMMKfBZ2FJQt1PtX5UCc8hvq8nxmHewBwGcLxcDAuW1hqw99b0fs1wPsO4EV4aa9djRm3Pynch5wi70TXxpylYibHAOo4bTl8qNtxKIPvUIZc+jJsaTIInXA6U4numx8++8HBbrfVvt9q9dqH4wl8DP9amQVnbgac1xjnu0d7e53HnXbvOy86h/0J3HkFt9xnjC4b84VwWDT/Hpad6NqYr2z6JMOXiK4jv9iokpxsK1ei+9M+ePvw0ck09M3hhDJp5xZI2DQVKfSXI3y+wlue6gT2a8QfJj2ulS60SmbSMXgxekuZr+1pnBjSLxqnxrnpmUk7WTKT+smQ7pYVXitKHSYzWId0lhU654WrbCb7O0d0NN3kLXS0cXBJJxmdktIuaUJQsfA8jU9A+0lxDN6e1icI/fPyCdr4svmEgsJrRanjcVxQ6BQUOouKS+yjCHU70bUxW9niFxqfQkfGINolj8FZfSS2F7iS0m7eMajxbBuDs9JxnV9o+uL8opiCHBXCFd5nScYVNzJuCf5VN/hPF3RKbvCfLnisgV5Twt0U3GU3vN8SG8IFKLGv0OaewHvPjCaHvhmNc2y7AvUI/ztvhPNp9K6stC8SPdEpLnQgfJboCfxBdC0QH2mPTy3/F1q8gMe67ZGsGZBlSWlbJlkF/ino9ih6p+mWcyrcQ81RHeqL/fO6GZfXmJGecVHyInIXoV8kXl3lLlXiB3UXFo4TNTf8bAs/dYWfdYWf8F3ZTPYZ8ie4cOyJDy2bSZ+Ktqb5W3yHvFSU9iWqyyt0tBi/TnUYN9eorkj8Ie+YG9j06BF/CK/FbNu4NNTOV2D9GLpZpb3mHwX+V9HV8ZxD9Y/sTy5gfeTutP7kcn3kEldauD5raxmOF7TvnJU//QHeo87j8if2qwL/yBvh/GP0zuanbfp17E9b0/otXsNx5Eetazia3fKcFdtqcZnHYVGhU1ToXOK6xHWJS48/Ws6QNM5h+/NaxzuvOCexhtddU/Whm42G4/Wp9llx9GN4H/5knjRtHBX4TwDnP6P7stJ+mepsMVY7gLJinK/r3BGe18/QRYV0IfD/ja6O10XU+RUfDMP1CF6zM2ZyLruuwFcIJizaOhKvDbF+ENYH+tiWeWbd/i+6hnb2TsRMSWknfBYU/On1wdbmNL4G6ReNU9vdnKYfw4JrQetmsn+KCu+BIaW6MeythnbKT5jQTvkJH6FzeS8zej+LIjzChfBoPLyYg0qrWtqtka5s9Gz81RR47IdVC381S7s4/taAD60dL9qfpb+1GHlyMfCCzyf4TDS6xBbrxP9O9NyYs2hOtk4yrIO8mo5KMTJnYmRmeK1v4hZuXdiUbOyUFV5tNrWu8B1Hz8aftrCNMpct/NVj6Nj4Wwc+tHZs81qQjdNDnM0jPAdOga8tgM07Tmq2WUdLMX3AiY7wh31Ws8BrfV9R5NXqcLN3yUyOUYw5mk3yxAt9nOYPOOkW+M+TPTja8FLtYd0iHyf5VUV2qatZ9HJWn4pfEvk3HMkv/Mgp2izws6Hw4xP8V7xxueRENNp2XcEj8FcVutcApkZ0rxJd0c91R/rR7ENoFUgXKdPe9agf/BidXiEdCfw3SEdX3fCp6kho2fJdyTezAyd8tcKx2qavVDA++0AX9WjM5JgMC8fuDQUebUH6qGImxxNPPLU4i328SvCiw1wMfNwE/ptkE45sV7UJoeU4xu9yf+K40eIg+7Qd0pEr36vpCGkhj8ZMZ5OaDWt2UTGT/S9xng/EcGxCWKSjzdXYvuPyQlycQ/i3qS8cHTRR+6JGurIdyMgrsuBCjk1v3ox686bQ28MFyJ9KFn5xgda2gM+bAogPaZboWTt8F+pWxsLp10LRP5t4r90c+y8YTJPpabQZjg9Qpqz7O2wjcYu5cTby4wWxkbBgfrAM+gtLduCEr7tafoB2xPmBNna1g1+2mM5rRMaMfIhtHq5tYNn8hrSP8xv88ZnAPyGbcGS7qk3wQTb0qaLnkkUWPDyhbcLwoZSzNoQypCOB73ojer/24unZDqbyPLKi8KnNP/njhaqC03F+tc25Rpz+4vKrY7KxRcuvsN2s+ZXIr60BXKE6be3AcV5+yyM9xPVd3JzyZ9R3FzGntPWFre/Omq9x32G/bhAvVXrWDhgv+jj8xQKMQy3+r4H+wpIdOOHr9qzrA2nPxTj+oy1WqW7ag+I8Z8GYx3M/bSMUY5pH9FAOtC/OPTDHnyWu/pbscVE+bsmAPD2SNemHQ7+HHCJPNnj+m/0v4wLSM+bTtdkvutP2pipKHefh2r6iFks0XNxHjvaPtoQWrolrNhe3r/xnGl8Xua+c9j6uwNv2cbVcO26PHz88QXj+8ETg/0K6vYh1KttcQpNPWxMtx8j3L/BXf/Xi6fGcR5ufaLkxz3nQXnjOc0Vp5zgfPc2br4F+tBzyqhnXn8D/nezjIvartFyrAvoLS3bghK9tLdfCnNoHuqhHYyb3I8PC/uGaAo+2IH1UIXj0FZo983xRW9PR/JZtz0ejM83hRhsd7YyFDReOvWn2lmoKft5b+phs/CL2lrR8eYPqMF/mPHvafLkOOorL3zwzfiD5E2/0nuP0LL54LTPC+e+Evph9KvYvH3jHeU9EznUfT/1htNAvmsm44SIfnXaP2PGcetvmJ+sKP/hhNPYZ8odnMeQdfxit+QHP6DlPnG609e5aAjomZTr1OenUFTqLFnPP8/xDgfSDtmaLubzXPGss1GxHo1Ofk45tXz2vyKPFHz4jgvFnleow/ogvx/hjkyOj4LXF+4wiG8f71QjoIj8GKVn4xX/0osVAnhtp82otR+N5dRXi8euZeHq284E8N6orfGr+m+P4hoJT+gdzXhex6PoZ+sO5E8K/SnZ0ww2fqh0hLeTRmOnmHdcVeNQz+x+ck1ynOuw73g9yNF88ndeKHuL6DvsW4V+jvnvFDZ9q3yGtuL6w9d0NBR71zH2H/XqDeOH9Iexnabfo4/DmAoxDLV+qgf7Ckh044UvdD8L8mvMl25pDWJL6ioqZtEWew2J+wXNYzC+uUh3GPM49ML+QGIMxzSN6KAfaF+cX2jch08TVN8geL2K9umThl+f0YckPzJhuTq7wTmxI7HwZ4amuAHXZwTidYvQs67iMS/jwCf77kJ+cyABtpH1FoZ8j+mN8K+/Q9hnXkvIO99jeih7kg+iwZAcjfGn1/d17L79/OOEpwu8Df1iyUI/wD8FGXfGp2SjSQj3l3NDfEj2J/cr3HcgH0tfsW+BO/wGBG14bPEawT9HmRJYMwfM9j6EW+EOUUeTAd4hf4FegTvMRwqM2RlcGs+FaJlz5OXAJXxUFPp+QLw0X+5pZfMcPwXdo+lsi3MI3+tGcgtsn+A7M+Z5CznACq9AL4Y4tcF7M9QSH8i47GH+n6Qj1LfBCu6jwKHXYF5jzhGU1ekZ9IS7hwyf45xR3cHxIe80WcGwxLY3+NGNtRYEP++cgepA8CGVPcy0ZbSG00/8Dx+rJejZzAAA=","debug_symbols":"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","brillig_names":["player_hand"]},{"name":"initialize_deck","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1ZS2/TQBDeJE4TJzGNQEggcfBPcACp5RaEEBKHcuiBK6Z2wfThKnUfPA4+wB0kDsABceGG4C+SrXaaL+Ox6cNbcehI1q693843OzM7XicNNZOGaduqRDTAUdXSYcq0LAr9lTTzk+0kS8LN5E0cIfwV9G+a9v5kEr6eTojiQz/dy/x03X+e7m1HuzhxF/q3TBtmWby1k/lZ6odR5B8k2Us/3Y8n65vpAc59e1bS92ed+PEc1n6B/hXTrmbh2sZ0ZupHcbxzHIA/pnVN2zStHm9Nr7G5D84nIxf01q1/Obh7x1XzUrP9R/obluzXQvot+T+gjfcgn+nHtRBv11xargFewfhn0x9Mr6Hph/tbT3bW0ii+H0WTeHculfm6quQ0Olun0HmD61zZ29xM1pN48vAw2c0Kuh1BN/Wb7FmzxC58jiLFWsvYtMH5ZNRmaxgy3haztSbe4CpbJ3J5SvbVBdgVNhifUsXcQf6esroXRw3GR/Zw/zSZ7xzBVvIdvpXH9dgZDAXeNvT5C78lPKM1XOq61HUaXYuqWBOajEfaP60KHr6ftXjCvEZJq5T8zuE8ks1uyRrG5j44p5B+XiNq0r9EflpQRT8Rd8cO9/JJ6zfx95ittup3h9nD/cPrd1ewdSiM8RzpCjxdgedS1/+py/L+GLkCd53nOg/8oRiXzvdHzGf0LdYGn+FcB8YRvw86H5v+oiqv3bRu3HPjWtZ8O/SMnlY+48V4anFyK/4OtW+/GV0e89GR34BXXz0Yawl4ntN9Ad8DDH43IB59LcXFZTxNgUc63w6F+VXvzbrfLTyHTuJDyecLgv1DVfQvnXGkc73L5uF7zrkYn9zj32OqPt2jf9WSZ2rez+SrslrShHHER6BzzfT7oIOfWVF4PvA40FzLdffeSetpl/mA8BvMzp4dO8XvfuRCG5Wq/ibga0Z8l2G0UB3CeNJc/bvPddM//t1nNUsn4Yv46STJYsWE/zjBk6At4BTDIA6Nx4B1GJ54FkrwuAkQn5nW9gFACjBxeRX24oamQLnMRrS/b8f+JbJvAH6U/Nxnfib8O2anZ8dO0c/IhTYqVf3RwdeM+D7DaKH44MYdVMzDF6DL8LYKIfmiLH4YX8R/YHZesWOnGD/ikg6ULtilxcmt2CUeKDF+/EAp5QzieY55An7AMFqGqpjTPBelwl9VO2l+We3ElyfiP5nWcu6KOTFg/sDDBfnZq1gLfnTZzJ2l5SAgfsrbtpo/GCrG32b4rxdgp+Rn5NIxp3+WF/LZOO5FLR1z76jZGhGPh03Efyfs9Pph+se1Ki/yadzvClyjpD3SITxz8vlnbl7Et/Iinrh7edFGGuvDGNYJLQNzj/5CXWRHm+F/mXuKSRfm0PyhwN9l/HN2C8/4H2x9Ad8X8Do+P0mfaXHtdf54g7mg8/QvUwbhVHMhAAA=","debug_symbols":"1ZzbiuJAFEX/Jc8+VNWpq78yNI12axMQbdQeGMR/n+hYMRPtc1602edFEt2klrmtgmxyaN4X86+P13a93Oya6a9Ds9q8zfbtZt2tHY6TZr5tV6v243X4dWNOH+Uc333O1qe13X623TdTG4uZNIv1e7eYjOk2sGxXi2aawnFyGzYm1LBxoQ/bUO6kKVPddLdY+nRJd8KRfLyEI0U3DL9MGmsewJ5dDXfwP8huH8Dubb/fo7Tfrcu+pskbnj1Fly7hFJMZs7uHslvzP/tpBHr6CP7pI4SnjxDvjpBzfzkWk4URqD/QlgJdR8j2TjoUUy7pUJznzyFKVMOUBptO7syeFLNnxexFL7szitmtYnanmJ0Us3vF7EExu2KvOsVedYq96hR7lRR7lRR7lRR7lRR7lRR7lRR7lRR7lRR7lRR7lRR71Sv2qlfsVa/Yq16xV71ir3rFXk3Y12r2ubLn6Mfs2OdMztSzFzdmhz5nvLGV3RtKY3bouZjADj0XE9ih52ICO/RcjGfP0HMxgR36/i6wQ8/FBHbouZjADu1VgV2xVzO4V2Pu2Uscs4N7lWUH9yrLDu5Vjr2Ae5VlB/cqy/7j95mcalMu5CKwhxhr2axbDMPwy6m3Z6Dh0/UoJVtu4C32ni+eg3fYe97ZHp5uaoeGNMN7zfBBMzz2rVKAT5rhs2b4ohjeYhs2ZnOFt3y4eFv/afHhtkcPruNv/+kZHlvHAjy2jgV4bB0L8Ng6FuCx2wjs0yoLXp/PpXJQcXYMD96fF+DBH3Ly8NiNBAEeu5IgwHvN8NilBAEeu+0nwGPX/Ybwg8l/hQc3LNepsOBFeh4evEkvwIMblocHNywPD25YHh7csDw8uGF5eHDD8vDghuXhNRsWvFLPw4N36gV4zYYFb9UL8JoNC96rF+DVGvbYrf2ebdvZfLW4vEZp+bV+G7xVaf/n898vXfgv","brillig_names":["initialize_deck"]},{"name":"view_deck","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"CardNote::CardNote::Deck","fields":[{"name":"drawn_cards_bitmap","type":{"kind":"array","length":7,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"deck_seed","type":{"kind":"field"}},{"name":"draw_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1azY7jRBDu/DixkxkS/qRdCYEfwSOQJnubZbVIgLRIzAMgb+wBi2w8SpyZneXiC9xB4gh3kJC4wQE4IC7cELwQ6WxX5nO57PlJencPU5LV7a7q+qqrq6s77TTUU3KXT8PUHVWklik1vwvt+r1p+G3Tr2N4XdC7EmwrmbxLKOwaRS7IEd2C+sCUD9LMT6ZJloST5EkcofibUA9M+d5iOs6SdOqfJPHpJ1E8/twfh1M/nU7O/Ifxsj6ZxJE/z8Is0fUz1PcE6rdNeXc2C8+WBkTxYz9dZH565D9MF9Nojh2/vG7Hr6H+hinDLIsfHWd+lvphFPmnSfaZn57Es6NJeop9v7su6A8bgP4G9ZdMeZiFSy9naepHcXy8ntD/TElB0TSl5uugODDvwWa054HebesfBe+MMagt2P+2Z3Q27OgPSL8l/weUHe7l5/pxLISrF/zLqiiDiaTF+iroS2Nw7Mzxeg46FvQvaX+Xxpif66exE68NPIfxHOB1wJ8/MbkPQK7JeB/mxbFpelWdz5sHen819Z3lMzT18OTRR8fjNIrvRtEsnhdSCo+vOrqKztYVdN7iOh8sJpPkKIln9x8n86ykuy3opnqTtTUr7MJ2JGnNaTowZbAZ7TlsDLcZbovZuiXc4BU2TsTSc/C6qa/n4P354Wqrvbfca68bMHxQ23SkYo50lJwskUeybzH7bCSnKqc7DLu5fd8Eu6qcpBvPZsxhg+EpVU4GiN9T5UW9zUNGg+GRPdw/mHT5hkJ9hwIP4w15iNMRcG503ei6iq6BKq/bNsORYtypwcH+eHDh/RoVJeHwNo4j2Wz7cOspu3nF8sHzDs0D+px8pTHfhXb90GHeUeUDOdrpMPlvQed9Ux/AeJSS9y2H4R9sZ9wBz79Klfeurh2fjy67dxF+T1mNgT0+t2RPVf4g37mCrUOBx+fQFXBcAedG14upi9Ytro8Ow5FiqVuDg/1Jblfot+keIdls+ay6f1GOHUM78qpyrAN8lF+AzqMKnQp0tgQ/kbx08dIUbBiosn3PaO8d1Z1H6sYmnZNw7vlZCPf2TgWOdAZoVYxf1ejgsgOhna8Pfj5DnhRzu4JO0tG/AJPm1GV2Hpj3YDO6QzbTZVPVGnCBj/JfMDt7duwUf3MjVlWurYtLT5B3mYwmmh/MmR7rh5fePDdLuiVs7OcKtnKcbeZMwiGfVsUBxgnKf2VKsrNvx04xDghLutTFC2tN7dyKXSM9X3+AHTweHcC9KPaUKsdqT5D3mIymoSqvDR6P0t4k7Sc8f3cq5HH/RPlvTGk5dsWY8Jg/8BxCfr7sOUE6fznMf1LekOzB8XN79IXta6a+vrA9zNJZ+Gn8cRwWPrVyTI4nYXM5yzl7vbfQ+qzKKZhzUP57ZueOHTvF+CEsKafg3qypnVuxK5RyCsYRzyl1OUITzyl9QZ7vqZqGqpzTebxLvz/qcgr1r8opeO+B8j+a8nmeN6T7L/Lzbs1Y+P2Opm6uCn5bldBGc0xx6KI843nAa+dFnJ55bwMO6iI7HCb/i3mnf390oA/1Hwr4HYZfsFto49+ePEHeE+S1T382dR2fNtfk/igIyD7yvaOKZ0zF8B0m/zuNxaKdUvwiFv3mWPkvP+djjtNEMYExg/K476P8nyS7fP4ydf7hHPG03L81co2KcqVDaGvnxTYplnCNkTxh9/KyjcTrAw/zr6Yd847+Ql1kh8Pk/zHvNCe4Lqj/UMB3GX7BbqGNr7G+IN8X5PX8/E36TIlj3+bdKMaCjtP/ATO4z2dDJwAA","debug_symbols":"1ZzdThsxEEbfZa9zYXtm7DGvUlVVgIAiRQFBqFQh3r0birdpNhoLGtB8N2iXzMYn8c8ZyRk/D9ery6fbH+vtzd3jcPHtedjcXS1367vtePf8shguH9abzfr2x+G/h7D/E/U1/vF+ud3fPu6WD7vhIuYaFsNqez1elhDGd7hZb1bDRZGXxTw4BGnBIckUHKWeiCal9tbjZZ2iazkRnInzW3CmnA6Dvy+GWM/ArqkFj/Bfx57CGdg5Tt977n3vMSm3aOJgs5ecyltwySUcs8ezssfwL/u+hfTpLdCnt8Cf3oL8dwsSYxsVEqk3KlLVNiooxeNRkd9Js3+mfOAZ/cAz9f3PUPjAMydnRkqxrQQpkXb6PDJNfZ7/BkeNp/pPQpuoIknt/pMkbbEbL+mo/ygBsxMwOwOzCzB7BmYvwOwKzF5x2TkAswN7lYG9ysBeZWCvMrBXGdirDOxVBvYqA3tVgL0qwF4VYK8KsFcF2KsC7FUB9qoAe1WAvSrAXs3AXs3O52qpE7se7+5k52Omts1GoXC8B1G+fMxwnYaBMNnsTNS2c8bLA470yh6B2RMwOwGzMzC7ALNnYPYCzK7A7BWXXYG9qsBeVWCvKrBXFdirCuxVBfaqAntVgb2qwF6twF6twF6twF6twF6twF6twF6tvtdInn5Wz8z5iD0G35M1h/YLas5JZ/C+Z2sH3vd07cD7nq85T/M1a53B+06EO/C+M+EOvO9UuAPve50/hK+zdT76ToY78L6z4Q68c8Pa8L5XGzu3ib5XG9Y6wdeZYaPzrNKET75Xmw6879WmA+97tenA+87nO/CMDO87n+/A+87nD+Al8AzeuWFteBjDnoJ3btgs05jXWW5Dzg1rwzs3rA3v3LA2vHPD2vDODWvDOzesDe/csDa8c8Pa8M4Na8MjG5aRDcvIhmVkwzKyYb++rPuc8MiGZWTDeq8wtipyovMSY6Kpm4hnh/Q5rzGmWCx430XGNO2Aj/CdCVIptG6qRDL7pM5Lkq2yr+i9JtmGd16UbMM7r3S04Z2XJdvwzuuSbXjgItPovTLZhnd+5IcN7/zMDxse2bAZ2bAZ2bDezxKw4ZENm5ENi3yMQyywhn0Z734uH9bLy83q7fD9m6ft1cFZ/Ltf939eGYN/Aw==","brillig_names":["view_deck"]},{"name":"dealer_hand","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"CardNote::CardNote::Hand","fields":[{"name":"cards","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":6,"type":{"kind":"struct","path":"CardNote::CardNote::Card","fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}]}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"bust","type":{"kind":"boolean"}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"7Zzdbts4EIXfxde5IIcc/uRVFovCadPCgOEUibvAIsi7V3Yj2bFcEk4ZY86wN4Edj6TzUbTOkWTN8+LL/d2Pb59Wm68PT4vbf54X64fPy+3qYTO8e365Wdw9rtbr1bdPx/9emN0fm/b1T9+Xm93bp+3ycbu4tSGbm8X95svwMhozrOHran2/uI38cjMvNobHYkM8FVvOZ6pdcuOqh5d5qs7xTHFwPrwWBxfouPjfm4XNDbQnGosH8dfTTqaBdm+ncQ+1cbeU/FjtvClrj4Hia3EM0Zxqt021W/NW+24L9OFbcB++Bf/hW+A/3gJbO84Ktq42KyincVY4sqezIlyoZrdMfMcy6R3L5MuXceYdy5z/ZuQ0jhsZS5V9br2b9nlIh32e7Ln9x2b8ojJTKu8/Jh4PdsNLd7L/HAFrd8DaPbB2BtYegLVHYO0JWHvG1e4NsHZgX/XAvuqBfdUD+6oH9lUP7Kse2Fc9sK96YF9lYF9lYF9lYF9lYF9lYF8Nwud7zJP2dHrVNQgf9zzeBGBnTq8NhqvnGZ+nacDelbWTd+NlVvL+sOpIe+0BWHsE1p6AtWdc7dEAa7fA2glYuwPW7oG1A/tqBPbVCOyrEdhXI7CvJmBfTcC+moB9NQH7agL21QTsqwnYVxOwryZgX03AvpqBfTUD+2oG9tUM7KsZ2FczsK9mYF/NwL6agX01A/uqNcDGag2ws1oDbK3WyJ7zTONTOcPt4Zl4K3vkgx9vslJgnomXnWoq4mXbK4c8TZs4nzay/bUiXrbBVsQLP9oUxZNsh62Il+2wFfGyj/MV8bKP8xXxXrb4PIkPRDPxss9fK+JlH+cDT8EsxHws/owOY0dSa1woF1N2U/DIfPhpGoVzmk0awy2bnI+L92Mo224gxtDJdj2MMZRtvhhjKPxcD2IMhZ9yQoyh/zuGfzyGsoMZxhjKvgKDMYayLwRhjKGm85RwaI31tnhPqulsokjqNWX+MqmmZH5EmsKMVFN+zmcbbY2kmlJumdR3Q6opMR6R2tl1P68p1x26rw23fmakmtJX8CVSVRmpSKoqI5VIWVVGKpKqykhFUk0ZKRx00MxPWVNGKpP6bkgVZSTLh0bPYXYuw4oyUoVUUUaqkCrKSMek0c1IFWUkG9OkI8/OZYKijFQhVZSRKqSKMtIb0lkaDIoyko1jcyhLZnbsvX6zqo889toSqaqMVCRVlZGKpKoyUpFUVUYqkmrKSDxdBSVrT0mFN/BqSaopI5VJNWWkMqmijERuSoPEc1KviJSn34pQnCV84W3Kfv9g2pk1l3+7Iryp2SWkIdlxzSHR0QT4BSo8IrUDFZ6Q2oEKD0jNQIU3YmsIKjwetQNFfWr7YlDUJ7zPgU63nkJKfArqewHVE40qoJqSURFUUzIqgmpKRkVQTcmoBCq8lV5DUE3JqAiqKRkVQXtJRsLb/zUE7SUZCW8s2BC0l2QkvGVhQ9BOkhEJ74XYELSTZETCeyw2BO0kGZHxvYB2kozIdJKMyHSSjMh0koxIeBfcdqC2l2Rke0lGsD2QLwbtJRlZ3wtoL8lIeLfshqC9JCPhXbgvAs1m+g1DtjNQRcmoCCq8u3dDUEXJqAyqKBmVQRUlozKo7wUUNTDsxaOGgL14VGPfi0c165146Y3Gy+KvfghmEyfxlMrimeL4wMdQa46L9+K9aPHOTbvJeZqJZ9nibSyJD7LFG38QX/mCZDcZWnaOZ6RR9hck80Rq7Ex8QhafgcVfvxNtS/EWWTwhixdux2Xxsu24Il62HVfEy7bjinhkh/XIDuuRHZaRHZaRHZaRHZaRHfb6PUFbiX8Z3v23fFwt79b3T8Myuw9/bD5vVw+b17fb/7//+mQo/gk=","brillig_names":["dealer_hand"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"BlackJack::player_hand_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"BlackJack::player_hand_parameters","fields":[{"name":"player","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"struct","path":"CardNote::CardNote::Hand","fields":[{"name":"cards","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":6,"type":{"kind":"struct","path":"CardNote::CardNote::Card","fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}]}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"bust","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"BlackJack::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"BlackJack::constructor_parameters","fields":[{"name":"player","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"BlackJack::initialize_deck_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"BlackJack::initialize_deck_parameters","fields":[]}}]},{"kind":"struct","path":"BlackJack::view_deck_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"BlackJack::view_deck_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"CardNote::CardNote::Deck","fields":[{"name":"drawn_cards_bitmap","type":{"kind":"array","length":7,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"deck_seed","type":{"kind":"field"}},{"name":"draw_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]},{"kind":"struct","path":"BlackJack::dealer_hand_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"BlackJack::dealer_hand_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"CardNote::CardNote::Hand","fields":[{"name":"cards","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":6,"type":{"kind":"struct","path":"CardNote::CardNote::Card","fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}]}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"bust","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"BlackJack::begin_game_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"BlackJack::begin_game_parameters","fields":[{"name":"player","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"BlackJack"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"card_deck","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"player_hands","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}]}},{"name":"dealer_hand","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000b"}}]}}]}}]}],"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"kind":"struct","fields":[{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]}]}},"file_map":{"7":{"source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"24":{"source":"use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"25":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"29":{"source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"34":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"59":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"72":{"source":"// CardNote.nr\npub mod CardNote {\n    use dep::aztec::{\n        oracle::random::random,\n        prelude::{PublicContext, PublicMutable},\n        protocol_types::{\n            address::AztecAddress,\n            constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n            traits::{Deserialize, FromField, Serialize, ToField},\n        },\n    };\n    use std::hash::poseidon2;\n\n    global MAX_CARDS_IN_HAND: u32 = 6;\n    global BITS_PER_FIELD: u32 = 255;\n    global TOTAL_CARDS: u32 = 52;\n    global FIELDS_FOR_DECK: u32 = 7;\n    global MAX_DRAW_ATTEMPTS: u32 = 5;\n    global BITS_PER_BYTE: u32 = 8;\n    global NUM_BITMAP_BYTES: u32 = (TOTAL_CARDS + BITS_PER_BYTE - 1) / BITS_PER_BYTE; // 7 bytes\n\n    //-------------------------------CARD-----------------------------------\n\n    #[derive(Serialize)]\n    #[derive(Deserialize)]\n    pub struct Card {\n        pub rank: Field,\n        pub suit: Field,\n    }\n\n    impl FromField for Card {\n        fn from_field(field: Field) -> Card {\n            let value_bytes: [u8; 32] = field.to_le_bytes();\n            let rank = ((value_bytes[0] as u32) + (value_bytes[1] as u32) * 256) % 14;\n            let suit = ((value_bytes[2] as u32) + (value_bytes[3] as u32) * 256) % 4;\n            Card { rank: rank as Field, suit: suit as Field }\n        }\n    }\n\n    impl ToField for Card {\n        fn to_field(self) -> Field {\n            self.rank as Field + self.suit as Field * 65536\n        }\n    }\n\n    fn card_id(rank: u8, suit: u8) -> u8 {\n        (suit as u8) * 13 + (rank as u8) - 1 // Ranks from 1 to 13\n    }\n\n    fn id_to_card(card_id: u8) -> Card {\n        let rank = (card_id % 13) + 1;\n        let suit = card_id / 13;\n        Card { rank: rank as Field, suit: suit as Field }\n    }\n\n    //-------------------------------HAND-----------------------------------\n\n    pub struct Hand {\n        cards: BoundedVec<Card, MAX_CARDS_IN_HAND>,\n        bust: bool,\n    }\n\n    impl Serialize<MAX_CARDS_IN_HAND> for Hand {\n        fn serialize(self) -> [Field; MAX_CARDS_IN_HAND] {\n            let mut fields = [Field::empty(); MAX_CARDS_IN_HAND];\n            //only serialize the cards that exist\n            for i in 0..self.cards.len() {\n                fields[i] = self.cards.get(i).to_field();\n            }\n            fields\n        }\n    }\n\n    impl Deserialize<MAX_CARDS_IN_HAND> for Hand {\n        fn deserialize(fields: [Field; MAX_CARDS_IN_HAND]) -> Self {\n            let mut cards = BoundedVec::new();\n            //only deserialize the non empty fields\n            for i in 0..fields.len() {\n                let field = fields[i];\n                if field != Field::empty() {\n                    cards.push(Card::from_field(field));\n                }\n            }\n            Hand { cards, bust: false }\n        }\n    }\n\n    impl ToField for Hand {\n        fn to_field(self) -> Field {\n            // Serialize the cards array into fields\n            let mut card_fields = [Field::empty(); MAX_CARDS_IN_HAND];\n            for i in 0..self.cards.len() {\n                card_fields[i] = self.cards.get(i).to_field();\n            }\n\n            // Hash the serialized data\n            poseidon2::Poseidon2::hash(card_fields, MAX_CARDS_IN_HAND)\n        }\n    }\n\n    pub fn new_hand() -> Hand {\n        Hand { cards: BoundedVec::new(), bust: false }\n    }\n\n    //-------------------------------DECK-----------------------------------\n    pub struct Deck {\n        // Bitmask to track used cards\n        drawn_cards_bitmap: [u8; NUM_BITMAP_BYTES],\n        deck_seed: Field,\n        draw_counter: u32,\n    }\n\n    impl Serialize<NUM_BITMAP_BYTES + 2> for Deck { // Implement Serialize with explicit size\n        fn serialize(self) -> [Field; NUM_BITMAP_BYTES + 2] {\n            let mut fields = [Field::empty(); NUM_BITMAP_BYTES + 2];\n            // Use first 5 indices for bitmap\n            for i in 0..NUM_BITMAP_BYTES {\n                fields[i] = self.drawn_cards_bitmap[i] as Field;\n            }\n            // Use last 2 indices for seed and counter\n            fields[NUM_BITMAP_BYTES] = self.deck_seed;\n            fields[NUM_BITMAP_BYTES + 1] = self.draw_counter as Field;\n            fields\n        }\n    }\n\n    impl Deserialize<NUM_BITMAP_BYTES + 2> for Deck {\n        fn deserialize(fields: [Field; NUM_BITMAP_BYTES + 2]) -> Self {\n            let mut drawn_cards_bitmap = [0 as u8; NUM_BITMAP_BYTES];\n            // Get bitmap from first 5 indices\n            for i in 0..NUM_BITMAP_BYTES {\n                drawn_cards_bitmap[i] = fields[i] as u8;\n            }\n            // Get seed and counter from last 2 indices\n            let deck_seed = fields[NUM_BITMAP_BYTES];\n            let draw_counter = fields[NUM_BITMAP_BYTES + 1] as u32;\n            Deck { drawn_cards_bitmap, deck_seed, draw_counter }\n        }\n    }\n\n    impl Deck {\n        fn new(deck_seed: Field) -> Self {\n            // Initialize with all zeros\n            let drawn_cards_bitmap = [0 as u8; NUM_BITMAP_BYTES];\n            let draw_counter = 0;\n\n            Self { drawn_cards_bitmap, deck_seed, draw_counter }\n        }\n    }\n\n    impl ToField for Deck {\n        fn to_field(self) -> Field {\n            let mut card_fields = [Field::empty(); FIELDS_FOR_DECK];\n            for i in 0..self.drawn_cards_bitmap.len() {\n                card_fields[i] = self.drawn_cards_bitmap[i].to_field();\n            }\n            card_fields[FIELDS_FOR_DECK] = self.deck_seed;\n            card_fields[(FIELDS_FOR_DECK + 1)] = self.draw_counter.to_field();\n            // Hash all card fields into a single Field\n            poseidon2::Poseidon2::hash(card_fields, FIELDS_FOR_DECK)\n        }\n    }\n\n    //-------------------------------BITMASK UTILITIES-----------------------------------\n    fn is_card_used(deck: &mut Deck, card_index: u8) -> bool {\n        assert(card_index as u32 < TOTAL_CARDS as u32); // Ensure valid card index\n        let field_index = (card_index / 8) as u32;\n        assert(field_index as u32 < FIELDS_FOR_DECK as u32); // Ensure valid field index\n        let bit_index = card_index % 8;\n        let current_field = deck.drawn_cards_bitmap[field_index as u8];\n        (current_field & (1 << bit_index)) != 0\n    }\n\n    fn set_card_used(deck: &mut Deck, card_index: u8) {\n        assert(card_index as u32 < TOTAL_CARDS as u32); // Ensure valid card index\n        let field_index = (card_index / 8) as u32;\n        assert(field_index < FIELDS_FOR_DECK as u32); // Ensure valid field index\n        let bit_index = card_index % 8;\n        let mut current_value = deck.drawn_cards_bitmap[field_index as u8];\n        current_value |= 1 << bit_index;\n        deck.drawn_cards_bitmap[field_index as u8] = current_value;\n    }\n\n    //---------------------------FIESTEL NETWORK-----------------------------------\n\n    fn feistel_network(seed: Field, input: u64) -> u64 {\n        let mut left = (input) & 0xFFFF_FFFF;\n        let mut right = (input >> 32) & 0xFFFF_FFFF;\n\n        // Round 1\n        let temp = right;\n        right = left ^ (feistel_function(right, seed, 0)) as u64;\n        left = temp;\n\n        // Round 2\n        let temp = right;\n        right = left ^ (feistel_function(right, seed, 1)) as u64;\n        left = temp;\n\n        // Round 3\n        let temp = right;\n        right = left ^ (feistel_function(right, seed, 2)) as u64;\n        left = temp;\n\n        // Combine left and right\n        let output = (left << 32) | right;\n        // Map output to 0..51\n        (output % 52) as u64\n    }\n\n    fn feistel_function(value: u64, seed: Field, round: u32) -> Field {\n        let value_field = value as Field;\n        poseidon2::Poseidon2::hash([value_field, seed, round.to_field()], 3)\n    }\n\n    //-------------------------------DRAW CARD-----------------------------------\n\n    pub fn generate_card(deck_seed: Field, draw_counter: u64) -> Card {\n        let card_index = feistel_network(deck_seed, draw_counter);\n        id_to_card(card_index as u8)\n    }\n\n    pub fn draw_card(mut deck: Deck) -> (Card, Deck) {\n        let mut card_index = 0;\n        let mut unique_card_found = false;\n        let mut final_counter = 0;\n\n        // Instead of breaking, we'll use the first valid card we find\n        for attempt in 0..MAX_DRAW_ATTEMPTS {\n            if !unique_card_found {\n                // Only process if we haven't found a card yet\n                let current_draw_counter = deck.draw_counter + attempt;\n                let current_card_index =\n                    feistel_network(deck.deck_seed, current_draw_counter as u64) as u8;\n\n                if !is_card_used(&mut deck, current_card_index) {\n                    // Found a valid card\n                    card_index = current_card_index;\n                    final_counter = current_draw_counter + 1;\n                    unique_card_found = true;\n\n                    set_card_used(&mut deck, card_index);\n                }\n            }\n        }\n\n        // Update the counter after the loop\n        if unique_card_found {\n            deck.draw_counter = final_counter;\n        } else {\n            deck.draw_counter = deck.draw_counter + MAX_DRAW_ATTEMPTS;\n        }\n\n        let card = if unique_card_found {\n            id_to_card(card_index)\n        } else {\n            Card { rank: 0.to_field(), suit: 0.to_field() }\n        };\n\n        (card, deck)\n    }\n\n    //-------------------------------CARD FUNCTIONS-----------------------------------\n\n    pub fn start_game(\n        deck: &mut Deck,\n        player_hand: &mut Hand,\n        dealer_hand: &mut Hand,\n        // card_deck_storage: PublicMutable<Deck, &mut PublicContext>,\n    ) -> (Hand, Hand, &mut Deck) {\n        // Draw two cards for the player\n        player_hand.cards = BoundedVec::new();\n        dealer_hand.cards = BoundedVec::new();\n\n        //draw two cards for the player\n        let (card1, updated_deck) = draw_card(*deck);\n        player_hand.cards.push(card1);\n        let (card2, updated_deck) = draw_card(updated_deck);\n        player_hand.cards.push(card2);\n\n        // Draw one card for the dealer (face-up)\n        let (dealer_card, final_deck) = draw_card(updated_deck);\n        dealer_hand.cards.push(dealer_card);\n\n        (*player_hand, *dealer_hand, deck)\n    }\n\n    // pub fn player_hit1(deck: &mut Deck, player_hand: &mut Hand) -> bool {\n    //     if let Some(card) = draw_card(deck) {\n    //         player_hand.cards.push(card);\n    //         // Check if player busts\n    //         check_bust(player_hand)\n    //     } else {\n    //         // Handle no more cards scenario\n    //         true // Assuming player busts if no more cards can be drawn\n    //     }\n    // }\n\n    pub fn player_hit(deck: &mut Deck, player_hand: &mut Hand) -> bool {\n        // Draw a new card\n        let (card, deck) = draw_card(*deck);\n        player_hand.cards.push(card);\n\n        // Check if player busts\n        check_bust(player_hand)\n    }\n\n    pub fn dealer_play(deck: &mut Deck, dealer_hand: &mut Hand) {\n        // Dealer must hit until the hand value is 17 or more\n        //need to make this a loop without while loop\n        if hand_points(dealer_hand) as u8 < 17 {\n            let (card, deck) = draw_card(*deck);\n            dealer_hand.cards.push(card);\n        }\n    }\n\n    fn card_points(card: Card) -> Field {\n        if (card.rank as u8 > 1) & (card.rank as u8 <= 10) {\n            card.rank\n        } else if card.rank == 1 {\n            11.to_field() // Ace as 11 initially\n        } else {\n            10.to_field() //Face cards (J,Q,K)\n        }\n    }\n\n    pub fn determine_winner(player_hand: &mut Hand, dealer_hand: &mut Hand) -> Field {\n        let player_points = hand_points(player_hand) as u8;\n        let dealer_points = hand_points(dealer_hand) as u8;\n\n        let player_bust = check_bust(player_hand);\n        let dealer_bust = check_bust(dealer_hand);\n\n        //player wins = 0\n        //dealer wins = 1\n        //push = 2\n        if player_bust {\n            1.to_field()\n        } else if dealer_bust {\n            0.to_field()\n        } else if player_points > dealer_points {\n            0.to_field()\n        } else if dealer_points > player_points {\n            1.to_field()\n        } else {\n            2.to_field()\n        }\n    }\n\n    pub fn hand_points(hand: &mut Hand) -> Field {\n        let mut points = 0;\n        let mut aces = 0;\n\n        // First pass: Calculate initial points and count the number of Aces.\n        for i in 0..hand.cards.len() {\n            let card_point = card_points(hand.cards.get(i));\n            if card_point == Field::from(11) {\n                aces += 1;\n            }\n            points += card_point;\n        }\n\n        // Adjust for Aces if points exceed 21.\n        // Adjust for Aces if points exceed 21.\n        let max_points = 21;\n        if (points as u8 > max_points) & (aces > 0) {\n            points = points - 10; // Adjust one Ace from 11 to 1\n        }\n        if (points as u8 > max_points) & (aces > 1) {\n            points = points - 10; // Adjust second Ace if needed\n        }\n        if (points as u8 > max_points) & (aces > 2) {\n            points = points - 10; // Adjust third Ace if needed\n        }\n\n        // The above conditions effectively handle up to 4 Aces in a hand.\n        points\n    }\n\n    pub fn check_bust(hand: &mut Hand) -> bool {\n        hand_points(hand) as u8 > 21\n    }\n\n    // pub fn generate_deck() -> Deck {\n    //     let mut deck: Deck = Deck { drawn_cards_bitmap: [0.to_field(); FIELDS_FOR_DECK] };\n\n    //     let mut index = 0;\n    //     for suit in 1..=4 {\n    //         for rank in 1..=13 {\n    //             let card_index = card_id(rank as u8, suit as u8);\n    //             set_card_used(&mut deck, card_index);\n    //         }\n    //     }\n    //     deck\n    // }\n\n}\n\n","path":"/Users/niallcheetham/Dev/aztec/blackjack/blackjack/src/CardNote.nr"},"75":{"source":"//functionality that i need:\n\n//make it super simple to start similar to kits\n\n// Player hits/stands to beat dealer's hand by getting as close to 21 as possible.\n\n// Dealer must hit on and up to 16 and stand on 17.\n\n// Player can only double down on 9, 10, or 11.\n\n// Player can either double down or split, player cannot split then double down and vice versa.\n\n// Player cannot split then split again or double down more than once.\n\n// Player who splits Aces can receive only one more additional card on a hand.\n\n// Player can get insurance if dealer might have a BlackJack.\n\n// Aces are high unless card total is already greater than 11.\n\n// Blackjack payout is 3:2.\n\n// No surrender.\n\n//some finds here\n//i had to use my own serialisation and deserialisation for the deck, default ones were not working\n\nmod CardNote;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract BlackJack {\n\n    use crate::CardNote::CardNote::{\n        Card, check_bust, Deck, draw_card, Hand, hand_points, new_hand, start_game,\n    };\n    use dep::aztec::{\n        context::PublicContext,\n        macros::{functions::{initializer, private, public, view}, storage::storage},\n        prelude::{AztecAddress, Map, PrivateMutable, PublicImmutable, PublicMutable},\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        card_deck: PublicMutable<Deck, Context>,\n        player_hands: Map<AztecAddress, PublicMutable<Hand, Context>, Context>,\n        dealer_hand: PublicMutable<Hand, Context>,\n    }\n\n    #[private]\n    #[initializer]\n    fn constructor(player: AztecAddress) {\n        // let mut deck = Deck::new(); // Start with an empty deck\n        // storage.card_deck.write(deck);\n    }\n\n    //this is just because the constructor is private\n    #[public]\n    fn initialize_deck() {\n        let deck_seed = 42;\n        let mut deck = Deck::new(deck_seed); // Start with an empty deck\n        storage.card_deck.write(deck);\n    }\n\n    #[public]\n    #[view]\n    fn dealer_hand() -> Hand {\n        storage.dealer_hand.read()\n    }\n\n    #[public]\n    #[view]\n    fn player_hand(player: AztecAddress) -> Hand {\n        storage.player_hands.at(player).read()\n    }\n\n    #[public]\n    #[view]\n    fn view_deck() -> Deck {\n        storage.card_deck.read()\n    }\n\n    #[public]\n    fn begin_game(player: AztecAddress) {\n        //read existing\n        let mut deck = storage.card_deck.read();\n\n        let mut player_hand = new_hand();\n        let mut dealer_hand = new_hand();\n        // let mut card_deck_storage = storage.card_deck;\n        // let (updated_player_hand, updated_dealer_hand) = start_game(\n        //     &mut deck,\n        //     &mut player_hand,\n        //     &mut dealer_hand,\n        //     // card_deck_storage,\n        // );\n        // Draw cards and update deck with returned values\n        let (card1, updated_deck) = draw_card(deck);\n        let (card2, updated_deck2) = draw_card(updated_deck);\n        let (dealer_card, final_deck) = draw_card(updated_deck2);\n\n        player_hand.cards.push(card1);\n        player_hand.cards.push(card2);\n        dealer_hand.cards.push(dealer_card);\n\n        //store the deck\n        storage.card_deck.write(final_deck);\n        //store the hands\n        storage.player_hands.at(player).write(player_hand);\n        storage.dealer_hand.write(dealer_hand);\n    }\n\n    // #[public]\n    // fn player_hit(player: AztecAddress) {\n    //     let mut deck = storage.card_deck.modify();\n    //     let mut player_hand = storage.player_hands.at(player).modify();\n\n    //     // Draw a new card\n    //     player_hand.cards[player_hand.card_count.to_u32()] = draw_card(deck, deck.drawn_count);\n    //     deck.drawn_count += 1;\n    //     player_hand.card_count += 1;\n\n    //     // Check if player busts\n    //     if check_bust(player_hand) {\n    //         // Handle bust (e.g., end game, declare dealer winner)\n    //         // Implement game over logic here\n    //     }\n\n    //     // Update the player's hand in storage\n    //     storage.player_hands.at(player).write(player_hand);\n    // }\n\n    // #[public]\n    // fn player_stand(player: AztecAddress) {\n    //     // Proceed to dealer's turn\n    //     dealer_play(player);\n    // }\n\n    // #[public]\n    // fn dealer_play(player: AztecAddress) {\n    // let mut deck = storage.card_deck.modify();\n    // let mut dealer_hand = storage.dealer_hand.modify();\n\n    // // Reveal the dealer's hole card\n    // dealer_hand.cards[1] = draw_card(deck, deck.drawn_count);\n    // deck.drawn_count += 1;\n    // dealer_hand.card_count = 2;\n\n    // // Dealer must hit until the hand value is 17 or more\n    // while hand_points(dealer_hand).to_u32() < 17 {\n    //     dealer_hand.cards[dealer_hand.card_count.to_u32()] = draw_card(deck, deck.drawn_count);\n    //     deck.drawn_count += 1;\n    //     dealer_hand.card_count += 1;\n    // }\n\n    // // Update the dealer's hand in storage\n    // storage.dealer_hand.write(dealer_hand);\n\n    // // Determine the outcome\n    // determine_winner(player);\n    // }\n\n    // fn determine_winner(player: AztecAddress) {\n    // let player_hand = storage.player_hands.at(player).read();\n    // let dealer_hand = storage.dealer_hand.read();\n\n    // let player_points = hand_points(player_hand).to_u32();\n    // let dealer_points = hand_points(dealer_hand).to_u32();\n\n    // let player_bust = check_bust(player_hand);\n    // let dealer_bust = check_bust(dealer_hand);\n\n    // let outcome: &str;\n\n    // if player_bust {\n    //     outcome = \"Player busts. Dealer wins.\";\n    // } else if dealer_bust {\n    //     outcome = \"Dealer busts. Player wins!\";\n    // } else if player_points > dealer_points {\n    //     outcome = \"Player wins!\";\n    // } else if dealer_points > player_points {\n    //     outcome = \"Dealer wins.\";\n    // } else {\n    //     outcome = \"Push (tie).\";\n    // }\n\n    // // Handle payouts and game over logic\n    // // Emit event or log outcome\n    // // For simplicity, you can store the outcome in storage or emit it using an event\n    // }\n\n    //     #[public]\n    //     fn player_double_down(player: AztecAddress) {\n    //         let mut deck = storage.card_deck.modify();\n    //         let mut player_hand = storage.player_hands.at(player).modify();\n\n    //         // Ensure player can only double down on 9, 10, or 11\n    //         let player_points = hand_points(player_hand).to_u32();\n    //         if player_points < 9 || player_points > 11 {\n    //             // Reject the action\n    //             // Emit error or revert transaction\n    //             return;\n    //         }\n\n    //         // Double the bet (implement bet logic separately)\n    //         // Take exactly one more card\n    //         player_hand.cards[player_hand.card_count.to_u32()] = draw_card(deck, deck.drawn_count);\n    //         deck.drawn_count += 1;\n    //         player_hand.card_count += 1;\n\n    //         // Update the player's hand in storage\n    //         storage.player_hands.at(player).write(player_hand);\n\n    //         // Proceed to dealer's turn\n    //         dealer_play(player);\n    //     }\n\n    //     pub fn hand_points(hand: Hand) -> Field {\n    //     let mut points = 0;\n    //     let mut aces = 0;\n\n    //     for i in 0..hand.card_count.to_u32() {\n    //         let card = hand.cards[i];\n    //         if card.rank == 1 {\n    //             aces += 1;\n    //             points += 11; // Assume Ace as 11 initially\n    //         } else if card.rank >= 10 {\n    //             points += 10;\n    //         } else {\n    //             points += card.rank;\n    //         }\n    //     }\n\n    //     // Adjust for aces if points exceed 21\n    //     while points > 21 && aces > 0 {\n    //         points -= 10; // Convert an Ace from 11 to 1\n    //         aces -= 1;\n    //     }\n\n    //     points\n    // }\n\n}\n","path":"/Users/niallcheetham/Dev/aztec/blackjack/blackjack/src/main.nr"},"82":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n        compute_unique_note_hash,\n    },\n    utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"97":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\n// TODO(9396): Remove.\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// TODO(9396): Remove.\n//unconstrained fn function_selector() -> u32 {\n//    function_selector_opcode()\n//}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert<let N: u32>(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// TODO(9396): Remove.\n//#[oracle(avmOpcodeFunctionSelector)]\n//unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"98":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        header::get_header_at,\n        key_validation_request::get_key_validation_request,\n        logs::{emit_encrypted_event_log, emit_encrypted_note_log},\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log_hash::{EncryptedLogHash, LogHash, NoteLogHash},\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_ENCRYPTED_LOGS_PER_CALL, MAX_KEY_VALIDATION_REQUESTS_PER_CALL,\n        MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    },\n    header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"119":{"source":"use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"124":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"132":{"source":"use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"159":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"160":{"source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"165":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"173":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    storage::map::derive_storage_slot_in_map,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<T, N> for Map<K, T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"181":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicMutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"223":{"source":"use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"303":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"305":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"306":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"312":{"source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    },\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"313":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n    utils,\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    ec::{pow, sqrt},\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"315":{"source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"316":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"320":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::default::Default;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"322":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedEncryptedLogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__VK,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    proof::verification_key::VerificationKey,\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"323":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"340":{"source":"use dep::aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator, traits::Serialize,\n    },\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}