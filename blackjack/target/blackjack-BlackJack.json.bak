{"noir_version":"0.36.0+b0cbf84eaf69f77628939184c9b869cfb3e15846-aarch64","name":"BlackJack","functions":[{"name":"dealer_hand","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"CardNote::CardNote::Hand","fields":[{"name":"cards","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":6,"type":{"kind":"struct","path":"CardNote::CardNote::Card","fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}]}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"bust","type":{"kind":"boolean"}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1bT28bRRSftXedrP9unD9NJQSLBAfExUlLU5CQUlUgcWkR/QDItbfUwrEjZ9MmnPwt4CPAGe5wgDsc4AgSBxBHuIPYSefZPz+/3TjxTnvJSKuZ3Xnzfr958+bN7HjtqGepllyOKXtqNhVNruur8FzfF0y9a9qVkmsluVaTy0+ucnJVjHwVsM4au0pO9UuCVI3yBrSltA1lqr83jMPeoBf32v3eZ1EXxV+G8q7J3z8edOLecBB2o3Y/Gn38uD3ohp32IBwO+qfhwygp9/tRNzyK23FPl09R4wmUr5v8zmjUPk0odKOTcHgch8NH4cPh8aB7hA0/h/JLJm/HcXRwGIfxMGx3u+HTXvw4HD6JRo/6w6fY9ssl2n4N5abJD4+PHqcz/RbKr86jHRz3495hYqpUyO/VJW304xL9/PmyoL8uAfrHEm3/vizhf5cADeCG5ueDuN35NGk5TGZEdDiZbu+Ygm/uCybXj/U03jf3reXSjg9689Z/u/XWRL+yw/+Gb3Q6dvS3SL8l+7dWjJ6746l+7Avh6jC9pmZlMPQXWVsFbakPnpUxvjkZg5IF/Unq1KiP46l+6jvVuVDnsToP6kpgT8eZlbsPcgWm48PxbN90WlfTcauD3qrRq5fSwDxvPzm4f9gZdqM73e4oOpoJKdy/stJFdBYvoHOb67x33O/3HvWi0XsnvaN4Trcr6KZygT0rpPDC55ikOafTvslby6Udj/XhOsMtMq454baarJ+Ipcdg05QnY/DB0YOzbdDdZB902cH11Xyw2M/JkIRPE84TuLmsjmRfYfwsBQ/R6CWGXczfNq2aYHeH4doIyEnacxieUvP+gvhlNT+p89xkOAyP+HD7YNDlPkFtAyX7C5WxDnFKAs6Vrvx0NdS8T7sMRxp/LwMH2+Oizts5KTnh8GccR+LsK7tzgsc9lZvuG7dI94od7pNN8aod/bdojHE8qS/aXu/Cc0dNX5I8Nb8RRp4ek/8LdO6bckOlx54s3/OZ7pxt0l00phN+WVldY3a47YlP2pwm25UFroFQx2NUWcApCzhXuq50XemS12aMTR7Dkeaxn4GD7UmuJrRbdm2WONveA9BaQzGd23Tf3LeWS7ukv2JH/+RgpmpHf0T6azb070zfodL2AQfwXF90CLPoPoDkY9B5aMoNob3P6vCAgvxHOkRQKr+9VwUwGjbsnuy/qN/BOfZsMHuS/CmzxZodnuK7PT8kbUB91rsN7zPKN5iMUlMfqENdwLhw+9SZHQgf23LO3LZjk+s+/G7KNaEd8fQF/fmNwe7OIvEW8cvKqu/uLDKOOtG4r5mLj09N4B4qZlQ7jr3bkk68iYR04k08dIBrOtPnFzGEw3ShPDoPBWBpAqxltOPOn4WXxa8pyOM4uBn8mhnt0vjVgYfUrsb4nWe/ekp/SinypM9j8l+YnHxxnfHfN/etJZMUZNdZHwLor2SjakqfCyl95vLS2KD+JpPP26doA9gQuGb5VCDwTsPL4rcuyGOfKxn81lNwsvgFwENqx31eWmTT7JDm8yjPF06S/8rkL9LnLW9qbnIb4ZzCMeAbHeKHY9bMkJfGviH0V6rDj4uKan6O4poj+SR/+cQYJ8UDvnEn+W9MbneTI/tDkNE//qKwJvSd6poZdjlvTMus/5uW+k98Now+F/hsCnw8Jv8d69c1c4++vS7oIfktAfcayDQZ7hbDJftsW7KP5B/bDHvDDnaHbLQJNpBsusFsRPI/MJ5bz9FGhJW136W55I6t8Orq2PK6M+XB12cPcNGOSs3PSZ342r0pyKMv0BgFan4+8RdPaZ3FMeY/uJENSynyaS/wP5ncsu+KPrHBsC2t8R0+njhvpHWQx7RfGE9bsVeyEWIhR6UW80nJhyW/CNT8+NM6T3NF2gs7Kn2fIL2rcf9O2xfiAR/K/2ZyX+BheyyazFZ4YB2wOk/oCx7kZNnNuaDdnAXs9qeatduL2D/VMvjiIW/Wjxj8hxHUh5gVdo8/8lJb/e5J/j75EutBPBy1P4k+itozX7hzTI4nYXM5y4f0k8PcydeQSvaRKtSj/D+MZ90OT9FHMNbohPsDH3jp5I6t8NqT9gfoR3x/gP/uKAryPBbXBHl+/qFTwOQlf5d+xMuKG9Q+LW7ghxUo/5/JLfuu6BNVZg+MqWTnWkZf+AckOq2M1YzdznJ4RmNMtl9FeVbnQ507nsUpm3t6j+G6iIfH5CtGwSTOQxtqHwj4JYY/w1t4xr+49QV5X5DXNnVNI/qBSid3PNWXl1/s3X72PnrGyej3gB8mF+pRfs0osBw75vwXsdBOJTv4u2Qn8l9630YeiC/5N8lN4q0dri0+R3BM0eeoLwUmz8t8Dr3mTHljH6kf+Az1k3wF6qQYQRylOVoZX0zXKtO1soQu4hUI8iuX5CXp4rHmIrFjC2KHZL8i0028MY6WBN0ek3/DmWK+CWv6mayAp+XezpBzUvIzHcIzdzz7TLIR2pvkCbsscKQ6HAvck+hUNfdoL9RFPDwmv8fWHZwf1F7yBZxbHEvCX2SuVQR5PT4UOCZnj4Cd5w/L6AvaT/8H0TtSH/Y7AAA=","debug_symbols":"7Zzdbts4EIXfxde54D85eZXFokjatDBgOEXiLrAI8u4rOxGtWsYIThljznBvAjsZyeejZJ1DRpqX1beH+18/vqy33x+fV7d/vaw2j1/vduvH7fDu5fVmdf+03mzWP75Mf70y+x+2HOqff95t92+fd3dPu9WtTWRuVg/bb8PLbMywh+/rzcPqNsfXm3mxMXEsNi7WYhvpTLUvftz18JJqNeUzxcmH9F6cfHLT4r9vVpYaaC9uLB7EX0+7Mw20B1vHPS2Nu3UljNU+GF57Ti6/F+eUzal221S7Nb9r33+C+/RP8J/+CeHTPyH+8SdEa8ezIlq/dFY4KuNZ4Z09PSvShWr22+QPbFM+sA1dvo03H9jm/DeDcj2MRHHhmNvg6zFP5XjMiz13/KIZv6gxusIfv+jieLEbXvqT4+cdsHYPrD0Aa4/A2hOw9gysvQBrJ1ztwQBrB/bVAOyrAdhXA7CvBmBfDcC+GoB9NQD7agD21QjsqxHYVyOwr0ZgX43AvpqEn++ZqvZyuuqahI87jf8EiN6crg2mq+eZQPU0iMHz2m0J47qmLZOF9OwO2hOw9gysvQBrJ1zt2QBrt8DaHbB2D6w9AGsH9tUM7KsZ2FczsK9mYF8twL5agH21APtqAfbVAuyrBdhXC7CvFmBfLcC+WoB9lYB9lYB9lYB9lYB9lYB9lYB9lYB9lYB9lYB9lYB91RpgY7UG2FmtAbZWa2Sf83TcNcWZeCt65J1JY7Ez2c3Ei041S+Jl2yuVdFbHu3jZ/rogXrbBLogXfrVhxTvZDrsgXrbDLoiX7bAL4mXPXhfEB9kmZVM1qckTvqN40fPXJfGir/NDJvBVPKWp+Hlx9qPmHApf6siPN6Y5iscb01w6p9iUccfREE2LDyMo2mwQRtCLdjyIERRtuxAjKHyOBzCCwieaACMY/h/BPxxB4VEMYARFr7hAjKDoZR+IEVQ0J8m1ZRLZ07mXVzRz4DiDonzPcipK4RPOMuPUk5WLGWuLzTNOPYmW5wydcOpJhxNOF2acejJcMeOOi59fbxUlrZwYTk15iOPUlIcYzqgpD3GcmvIQx6lo7TDHyjnzz6hohY/lDJ1wKspDaexYW/JsvhIV5SGWU08e4jn15KEJZ5ndFRH15KFSGySTmc1Xkp48xHPqyUM8p6L1oSOnneW+pGh9qFDlnF1vr99k6hOvt57h1JSHOE5NeYjj1JSHOE5NeYjjVJSH6mMP5Pwpp+xmWw05FeUhllNRHmI59eQhijX3pTln0MNZNVOZ5XjZjcSYR8fO7Jm/40R227GLSFOxY3EqbnK//xuo8EjUDlR4JmoHKjwUNQOV3SqtJajwWNQOFPW56otBUZ/BPgdaZ2jptyXrN9DQC6ieaLQAqikZsaCakhELqikZsaCakhEHKrvZXUtQTcmIBdWUjFjQXpKR7AZ9LUF7SUayW/+1BO0lGcluKtgStJNk5GR3K2wJ2kkycrK7ILYE7SQZORN6Ae0kGQ176gW0k2TkTCfJyMnuU9sQ1PaSjGwvyQi2S/HFoL0kIxt6Ae0lGcnuZ90StJdkJLtP9mWgVJstJLIzUEXJiAWV3X+7JaiiZMSDKkpGPKiiZMSDhl5AUQPDQTxqCDiIRzX2g3hUs96Ll94OnBd/9UtwNLmKd4UXH10en/Mdas20+CA+iBbvfT1MPriZ+ChbvM2c+CRbvAlH8QtfEPLV0Mj7OCPNsr8gFCupsTPxBVk8AYu/fg/ZluItsniHLF64HfPiZdvxgnjZdrwgXrYdL4hHdtiA7LAB2WEjssNGZIeNyA4bkR32+p0+W4l/Hd79c/e0vrvfPDwP2+z/+Gv7dbd+3L6/3f378+0vQ/F/","brillig_names":["dealer_hand"]},{"name":"begin_game","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"player","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["begin_game"]},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"3469988399892582431":{"error_kind":"fmtstring","length":20,"item_types":[]}}},"bytecode":"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","debug_symbols":"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","brillig_names":["compute_note_hash_and_optionally_a_nullifier"]},{"name":"player_hand","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"player","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"CardNote::CardNote::Hand","fields":[{"name":"cards","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":6,"type":{"kind":"struct","path":"CardNote::CardNote::Card","fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}]}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"bust","type":{"kind":"boolean"}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","brillig_names":["player_hand"]},{"name":"constructor","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"player","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"databus"},"error_types":{}},"bytecode":"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","debug_symbols":"7V3Rbts6DP2XPPdBpCiJ6q9cXAxp1w0BgnRouwtcFP33KV4lK7UTNYiTqLT2MNQto/CcY8uHtGW/Lr4/3P3++W21+fH4vLj953WxfrxfvqweN2HrdQG6+93zr+Vmu/n8snx6WdyC9epm8bD5Hn50Sr3dLH6s1g+LW2febgbByJreg5GNTcFg1Ui0NmDeo7VhLkRD+BcHDz9iH68Rx+KZbQz3yvTRNDo4+jS24zz435sFUGNmDzOmMbOHGduY2cOMO5kZUhixkrKQgj13X8Dn/gJ/urZoIp+InGlr/Ei0oxjsuOceNG6zQXXpbKDPxu5kMzKyQowjE/VpaBiLJnCJdvA22ydVhxRmgxRng1TPBinNBqmZDVI7G6RuNkh5Nkj9XJBqQR6JVEyaCGGAVJBHKiAV5JEKSAV5pAJSmg1SQR6pgFSQRyogFeSRCkgFeaQCUkEe6TBSEuSRbN++szRwgyTIIxWQCvJIBaSCPFIBKc0GqSCPVEAqyCMVkArySAWkgjxSAakgj3QYqRHkkZjiRVpiN3CDRpBHKiAV5JEKSAV5pAJSmg1SQR6pgFSQRyogFeSRCkgFeaQCUkEe6TBSe2mP5NnFkZUqQnWK49CcDT0OFRDTXXLoKYu2I9HWxEQ4v0UOxiCCsjrdUacs+YzG0UwoSQREGenH34BnoQlUt0DYBKpbIN0E+pRATvcCsSsJNN09xpaaQHULZAQJBL1Aeof0MYHA9NOQ9VCKvqJEtklUu0Suaoks6SSRdwWJ0KeZC73TWbQeidYAUX4dSpadGqQuq8BNotol8k2iyiVydfcUmkRBorq7Ck2iIFHdfYUmUZCo7s5CkyhIRE2i2iWqu7vQJAoS1d1daBIFiVp3oXqJWneheolad6F2ibh1F6qXqHUXqpeodRc+K9G1rhdx6y5ULxHJkUgrFa+6hkunpiDRNUkX1C/4OqQL6gBoTE9T1Gi4QHqYgCIvSBnlSEXG+3kOTUeioBr9nCR6YxKJ2Z6Iow9/tBEi+Yxv2/EtqOA+I9+oFMRghXQC34Kq53PyDZASAe0/TBJeUH17ThJDdI9RH95pQfcYKTsRvjMuqFz9IowLqj6rYdzo5A1N9gDqo2dxL6julCcONXGmFyc9jjJwcILf9JIqU3HiSKpgwdteHF8QJ7SKY9uYKGunjYqjXeJQM+g8eEuipAr2jCSyjxWV9kMSJZWlVyNRUq15LRIDksbiBCxKKiCvx6KkovB6LEqq3q7HIjUWJ2BRUj10PRZb4TIFi1IrF1u6myJMZgmjyp4ANMqiAR9rcxM6AAMWpZYul2VRau1yURZBau1yWRal1i4Ts4jprY4GrR2wKLV2uSyLUmuXy7JIjcUJWJRau0zMonXRdRsHBYvu+tvdneWBRQephU7FlLeq6FOUMyTK2eBplLcS6gyU+4jROYAB5a3eujTldb/nHPrVKCGPHca75Kt+nUIp+XYZ5XPtwpSIZuMG+2+7jDIFi3RFFsHtsNjlM4Gp14keDOgL+WB/N00QSheir7i+B6Z4ObpUaiYwyTqdLZEId8B2XzGBKTRpKRka9AU+jfMmnetB7cwJXUK+soSmeCn4tAlNYBJMqhTQOFc6BEBneykNE8LaEtK1JUS1JWSm2Kl1nxAPZpYJXujMEEFw9tCBPUdNP++afAHk9s7dkXO7wv7krozJw7vk3VdNPmzcPa3W69XPb+vH++XL6nHzvP2w2v433nUx6anXxsLAuvDxH/FHf2S8ajv8ETj+I3jkR8IWdLyNz3Aqla2g9M5So5FKK50CHGAe2u1u5x2eTh8+rSJx9HHd4J6G9XHDY2pcfVy7vKc5O9nw7vThOR7pLiuJ3ofn8w7vTx6e02TC9HHP2dNMOW74aGZ4d/nR3kP4uOFdlJYH5CBOOLz/cFiFDTwwNYBKD8wBxZ87YoDSghOwhaVarEw8FbFyu0tO3sLWf8un1fJu/bCd+7d//L25j6eCsPny/6+/fwnBfwA=","brillig_names":["get_contract_instance_internal","decompose_hint","lte_hint","directive_integer_quotient","directive_invert"]},{"name":"initialize_deck","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/71WS28TMRD2Zh/tJkAjEBJIIK2EkODERg0iiAOJENdy6IHz0nXAIq2jjdPXKT+9cWUnX2edtFXXHWk1k91vvnl47DhgawmMjtkG0YCIbZeIkGnZc9gHUmXiRChRTMQlLxH+CezXRo+qqrhYOpT8PJNzlclx9kfOT8oZOg7AfmN0oRQ/nqpMyawoy+xMqH+ZPOXVeCLP0Pc72M+MPlTF0f+lp8xKzqerkkZGp0a3oORw+QzN7/xh0kuBt2n+Qd7fT9lNaTj/a/7AU/5aLL+n/uc7hufHYs2Ptdi4u+bR8gLwDL5/M/aT5dM1dnF6/Gt6JEs+KsuKz26MMq1rm9yHM7wH5yvKeTCfTMRY8OrnuZipGrdr61u7Rd61NuSF71Fca61laHT+MOnFpIYuiRuSXBuKmz8ndWIsz/Pdo7UxD9yRl9z3+5Y/bj731bmS+Ol7/tRw7pB1xzXf9dO3zwGJx1j9TMD4bZJr0zMYkHg2H9qfFulP6qc//YDwYz6poz92LduOb5arY37HwIV4vEcgHm3rj+/eGd11cMYkhzar14PvbH/1zL8lteFcJIB7T2IkjjrRNyJ1WPxH4Pxg7A5wJCQOCp0delZb38eam/YtPUhJDyw+J3l2vOTp/r/BWJtm37UXt81WSjBa9lh9Pa2vvm+8NPbqvnGoZFX85b8roTgjQi8QdAgSB44RDOIwedcljx5UyQY8bgLEfzXa7yC6F9jGuuuGtvho0XyOXwZ5buOHi3WvQlaXCL4jfvgIebp6ibH0prkCsH6Gqz0PAAA=","debug_symbols":"1ZhRb4IwEID/S595uGt7bc+/siwGFQ0JQaO4ZDH+95XNomOsvoApL6SFL72v5eiRXsSmWJ13y7Le7k9i8XYR1X6dN+W+9r3LNROrY1lV5W75eFtAe+Fv/HTI67Z3avJjIxZoGDJR1BvftAB+gG1ZFWJh6Zr9hQEowCCpg5F4gFZOhaF9kzua7QBslDY32CgjH+H3TCCM4O5kgL38C91xBHeN3bqbZ+uO0ulAKw1xd2ukvcHWWOi7y1HdEX67txHU5BH05BFo6gjKDkZwJuQdOsdPIqjuRaMidY/gcIAmZ8PXQo51PIfImJBwvkm9HNKYtLsFDrBF7rvLtNeddcRdpb3uEjt31d93tJ6xO83Y3czYPe09Mu7uZuzO83UnmLF72nXVOLi7YxxmjWGirKn/A02JF+F/J9q6p12E4+5pF+G4e9pFOO6edhGOuF997yM/lvmqKm7HEdtzvX44nWg+Dz9PPPwF","brillig_names":["initialize_deck"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"14336010898202591232":{"error_kind":"fmtstring","length":16,"item_types":[]}}},"bytecode":"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","debug_symbols":"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","brillig_names":["public_dispatch"]},{"name":"view_deck","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"struct","path":"CardNote::CardNote::Deck","fields":[{"name":"drawn_cards","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":52,"type":{"kind":"struct","path":"CardNote::CardNote::Card","fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}]}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2YaXMbRRCGR/auTjsWIQEHkrCc4Qqs4yMO4bBxEggQG2Ig4Qxr7dpeULRGXl8URamKbxT8Ev4k7zjTVm9r5HJiLcUHpuqpuXq6e3qOHamgHqR1UDBlV2XTkMkLRk6xuu4bBo4ZVwQlUAYVUAU1MAJGwQkwBurgMXASPA5OgdPgCfAkGAdnwFPgaXAWnAPnwTPAA8+C58Dz4AXwIngJXAAvg1fAq+A18Dq4CN4AbwIfTIBLYBJMgWkwAy6DWXAFvAWugrfBO+Bd8B6YA/PgfbAAroHr4Ab4AHwIboKPwMfgE3ALLIIl8Cn4DNwGy+Bz8AX4EtwBd8FX4GvwDfgWfAe+B/fADyAAK6ABQhCBVbBm1medFslR9hSz8v+L+d9dzHXVPZR0SJWJLaUxky8mqRe34jQOmvEvUcjFz7Gyb/IbW61GGictbzuOdu6FUeMnrxG0vKTV3PNWIpSbzSj0NtMgjXV5j+u7w8pnTD7fbgd7cCCMdr1kK/WSVW8l2WqFm3xgg5XPmjxI0+j+RuqliReEobcTp+tesh21V5vJDh+7zconTL6cBvA7TRIvjKKNgxD9ZfKKyfk9prf5HMXieGmiwvQOWv+sHzQqKpsG7P9kxegs5KPfJ/05xd8vGT0Lna5+Pheyq6+xusrKDLO4Douxio2lOTi5rPHUwRq4Oej3/ZnZUZpjJ6tfJ+pzWJ8j+lzW57J4rgm5v5kcxU5/EmhtYja2bcr6c0LrEmzfX9poJGE0H4btaDNzbcg9dFh6GJ3DD6FzXOpc3Go249U4al/fjTfTHt2ORTeVh0TbUB+/eDtPtnOl05zJ/eOlCVfMYVzYHRa+Dsiuf1LMk9vSa3DalA/W4Obm8v4HagFfqEfdMHJSgwykEoF0lf1C5H0ke174l88FYQ+6K2wPDT42/qjqfaMW/pU5T04XhD2lei8Dbr+q8vsIIE0UhD3yR8ZHfpSK+cRnqiD0c3+KlvjQWpYsfaSrbOou08Xli2yOXJ6XaTxvu2jyukXnkPChpHrnw9tIXvtywZTHLPNxhF7burkWvXXLeBlDPq7QJyc7sk3asfmc54NGp3z35oNHt1znQe59WoeCJXZ6TrOsvd++5mNLrJ/LLzGdV01Z2laq907M5+M7c+WodyK1VVWuPx4mHvWhntdD+ihnnfub8zm4RHulbLFNvtIPSL43ubzLYsjleZnG87ZbJrfd+6R/kPfxUXSVLbr4XGkddH5N+M910VnX/3eNqf4xIxsV4QdPul4Vdb5GNFY/bk+Z8sHjdjlN2sFadDsKQnkfyD8elKXObUs52ps14decqfvHSt33w4jR1+9urLF+Ln9X+Dmai5/2ty/Zsv1wLjO/dHI6ucRvWtvZZX7IfeQyuzyOSnXjzOXlWRmxyNeEjE51IW/b77Zzx9e4KORpfLGPPP+ecvnQ5PnuXfueqIl48Pue4jx6yFzku0GnUkdl4rafszZaY9qHZS4v+iqsz+lk7VRN3WF2uC7ywxXyP5s6/b9cZGNofN1ivyjsZ/y2tMnf6RWLfMUir2P6oynr9cnzTF6e9X3yj2LvquzbRAn7rpDfobnk6Kdt/3Jb9E3bj1+n28/vOJ1oT/A9w+VpDVwh/yvJgt9MWf6RyO1puT8PkSv0yfd1WNqcTrbNtpf4GSN5sl3t9PpIfTXWx+9fnUZMnceL6yI/XCH/h6nTmvBzQePrFvtlYT/jt6VNnrGaRb5mkdfr8zvpMzmf+yDf+3wv6H36Dxqk/7uhHgAA","debug_symbols":"1ZrRbsIwDEX/Jc88xLGdxPzKNE1lg6lSVSZgkybEv69spGNdFQSDKX5BDVw3p7HDtaJuzdN89vr8ULeL5dpM77amWT5Wm3rZdqPtbmJmq7pp6ueH46+N3X9A+NSvX6p2P1xvqtXGTMGLnZh5+9RdBmu7OyzqZm6mgXeT32JrOYmt414MLCNqjJhu3V1Kr5YwIvZI/iD26N2x+H5iIF6BPbok7uD/kV2uwE7Qr7s/te7gIiU1ks2zB+/CQRx8sAN2Z6/KDvYn+34GuPkM7uYz4M1noD/PwACpKhjwVFU4iakq0MGwKvhMmn2MvyAmXBATL4iR82NwdGc4EDnEOHe0buM5B8I+5z5+5zzCWP7Ypo3K7GI+f+w4/dl1lzjIH4JidqeYHRWzk2J2VszuFbMHxexRMbvoZSfFvkqKfZUU+yop9lVS7Kuk2FdJsa+SYl8lxb5Kin2VFfsqF75Xg/TscXiCFgqvmRx7LLtmEPuaQRqeusayezGEkGEvuxdDS9/smBcL2pQkQeThgxbeuAn3D2qHh6CRFLMX3rhl2Qs3gyx74Y1blr3wxi3LXrgJ59il8MYty174gUiWvfADkSy7Yl8Vxb4qin1VFPuqKPZVUeyrothXwao11l03eqtWdTVr5ofXvhav7ePRW2Cb95evXzrxBw==","brillig_names":["view_deck"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"BlackJack::player_hand_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"BlackJack::player_hand_parameters","fields":[{"name":"player","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"struct","path":"CardNote::CardNote::Hand","fields":[{"name":"cards","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":6,"type":{"kind":"struct","path":"CardNote::CardNote::Card","fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}]}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"bust","type":{"kind":"boolean"}}]}}]},{"kind":"struct","path":"BlackJack::begin_game_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"BlackJack::begin_game_parameters","fields":[{"name":"player","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"BlackJack::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"BlackJack::constructor_parameters","fields":[{"name":"player","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"BlackJack::view_deck_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"BlackJack::view_deck_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"CardNote::CardNote::Deck","fields":[{"name":"drawn_cards","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":52,"type":{"kind":"struct","path":"CardNote::CardNote::Card","fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}]}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]},{"kind":"struct","path":"BlackJack::initialize_deck_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"BlackJack::initialize_deck_parameters","fields":[]}}]},{"kind":"struct","path":"BlackJack::dealer_hand_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"BlackJack::dealer_hand_parameters","fields":[]}},{"name":"return_type","type":{"kind":"struct","path":"CardNote::CardNote::Hand","fields":[{"name":"cards","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":6,"type":{"kind":"struct","path":"CardNote::CardNote::Card","fields":[{"name":"rank","type":{"kind":"field"}},{"name":"suit","type":{"kind":"field"}}]}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"bust","type":{"kind":"boolean"}}]}}]}]},"globals":{"notes":[{"kind":"tuple","fields":[{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000003de78269"},{"kind":"string","value":"ValueNote"},{"kind":"struct","fields":[{"name":"value","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000000"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"owner","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}},{"name":"randomness","value":{"kind":"struct","fields":[{"name":"index","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}},{"name":"nullable","value":{"kind":"boolean","value":false}}]}}]}]}],"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"BlackJack"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"card_deck","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"player_hands","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000035"}}]}},{"name":"dealer_hand","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000036"}}]}}]}}]}]}},"file_map":{"7":{"source":"use crate::{cmp::Eq, convert::From};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        let mut exceeded_len = false;\n        for i in 0..Len {\n            exceeded_len |= i == append_len;\n            if !exceeded_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        let mut exceeded_len = false;\n        for i in 0..MaxLen {\n            exceeded_len |= i == self.len;\n            if !exceeded_len {\n                ret |= predicate(self.storage[i]);\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n        for i in 0..MaxLen {\n            if i < self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        }\n        ret\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        (self.len == other.len) & (self.storage == other.storage)\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.storage()[2], 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n            assert_eq(bounded_vec.storage()[2], 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.storage()[0], 1);\n            assert_eq(bounded_vec.storage()[1], 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"24":{"source":"use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    let g1 = EmbeddedCurvePoint {\n        x: 1,\n        y: 17631683881184975370165255887551781615748388533673675138860,\n        is_infinite: false,\n    };\n    multi_scalar_mul([g1], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n","path":"std/embedded_curve_ops.nr"},"25":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(unsafe { field_less_than(b, a) });\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"29":{"source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"34":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        if message_size == N {\n            Poseidon2::hash_internal(input, N, false)\n        } else {\n            Poseidon2::hash_internal(input, message_size, true)\n        }\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"59":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"72":{"source":"\n// CardNote.nr\npub mod CardNote {\n    use dep::aztec::{protocol_types::{\n        address::AztecAddress,\n        constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n        traits::{Deserialize, FromField, Serialize, ToField},\n    },\n    oracle::random::random,\n    prelude::PublicMutable,\n    };\n    use std::hash::poseidon2;\n\n    global MAX_CARDS_IN_HAND: u32 = 6;\n    global MAX_CARDS_IN_DECK: u32 = 52;\n\n\n    //-------------------------------CARD-----------------------------------\n\n    #[derive(Serialize)]\n    #[derive(Deserialize)]\n    pub struct Card {\n        pub rank: Field,\n        pub suit: Field,\n    }\n\n    impl FromField for Card {\n        fn from_field(field: Field) -> Card {\n            let value_bytes: [u8; 32] = field.to_le_bytes();\n            let rank = ((value_bytes[0] as u32) + (value_bytes[1] as u32) * 256) % 14;\n            let suit = ((value_bytes[2] as u32) + (value_bytes[3] as u32) * 256) % 4;\n            Card { rank: rank as Field, suit: suit as Field }\n        }\n    }\n\n    impl ToField for Card {\n        fn to_field(self) -> Field {\n            self.rank as Field + self.suit as Field * 65536\n        }\n    }\n\n    //-------------------------------HAND-----------------------------------\n\n    pub struct Hand {\n        cards: BoundedVec<Card, MAX_CARDS_IN_HAND>,\n        bust: bool,\n    }\n\n    impl Serialize<MAX_CARDS_IN_HAND> for Hand {\n        fn serialize(self) -> [Field; MAX_CARDS_IN_HAND] {\n            let mut fields = [Field::empty(); MAX_CARDS_IN_HAND];\n            //only serialize the cards that exist\n            for i in 0..self.cards.len() {\n                fields[i] = self.cards.get(i).to_field();\n            }\n            fields\n        }\n    }\n\n    impl Deserialize<MAX_CARDS_IN_HAND> for Hand {\n        fn deserialize(fields: [Field; MAX_CARDS_IN_HAND]) -> Self {\n            let mut cards = BoundedVec::new();\n            //only deserialize the non empty fields\n            for i in 0..fields.len() {\n                let field = fields[i];\n                if field != Field::empty() {\n                    cards.push(Card::from_field(field));\n                }\n            }\n            Hand { cards, bust: false }\n        }\n    }\n\n    impl ToField for Hand {\n        fn to_field(self) -> Field {\n            // Serialize the cards array into fields\n            let mut card_fields = [Field::empty(); MAX_CARDS_IN_HAND];\n            for i in 0..self.cards.len() {\n                card_fields[i] = self.cards.get(i).to_field();\n            }\n\n            // Hash the serialized data\n            poseidon2::Poseidon2::hash(card_fields, MAX_CARDS_IN_HAND)\n        }\n    }\n\n    pub fn new_hand() -> Hand {\n        Hand { cards: BoundedVec::new(), bust: false }\n    }\n\n    //-------------------------------DECK-----------------------------------\n    pub struct Deck {\n        // only track the cards that have been drawn\n        drawn_cards: BoundedVec<Card, MAX_CARDS_IN_DECK>,\n    }\n\n\n    impl Serialize<MAX_CARDS_IN_DECK> for Deck {  // Implement Serialize with explicit size\n        fn serialize(self) -> [Field; MAX_CARDS_IN_DECK] {\n            let mut fields = [Field::empty(); MAX_CARDS_IN_DECK];\n            for i in 0..self.drawn_cards.len() {\n                fields[i] = self.drawn_cards.get(i).to_field();\n            }\n            fields\n        }\n    }\n\n    impl Deserialize<MAX_CARDS_IN_DECK> for Deck {\n        fn deserialize(fields: [Field; MAX_CARDS_IN_DECK]) -> Self {\n            let mut drawn_cards = BoundedVec::new();\n            for i in 0..drawn_cards.len() {\n                drawn_cards.push(Card::from_field(fields[i]));\n            }\n            Deck { drawn_cards }\n        }\n    }\n\n    impl Deck {\n        fn new() -> Self {\n            Deck {\n            drawn_cards: BoundedVec::new(), // Empty at start\n        }\n    }\n}\n\n\n    impl ToField for Deck {\n        fn to_field(self) -> Field {\n            let mut card_fields = [Field::empty(); MAX_CARDS_IN_DECK];\n            for i in 0..self.drawn_cards.len() {\n                card_fields[i] = self.drawn_cards.get(i).to_field();\n            }\n            // Hash all card fields into a single Field\n                poseidon2::Poseidon2::hash(card_fields, MAX_CARDS_IN_DECK)\n        }\n    }\n    //-------------------------------CARD FUNCTIONS-----------------------------------\n\n    fn new(rank: Field, suit: Field) -> Card {\n        Card { rank, suit }\n    }\n\n    pub fn draw_card(deck: &mut Deck) -> Card {\n        let card = generate_card();\n        if deck.drawn_cards.len() < MAX_CARDS_IN_DECK {\n            deck.drawn_cards.push(card);\n        }\n        card\n    }\n\n    pub fn start_game(deck: &mut Deck, player_hand: &mut Hand, dealer_hand: &mut Hand) -> (Hand, Hand) {\n        // Draw two cards for the player\n        player_hand.cards = BoundedVec::new();\n        dealer_hand.cards = BoundedVec::new();\n\n        //draw two cards for the player\n        player_hand.cards.push(draw_card(deck));\n        player_hand.cards.push(draw_card(deck));\n\n        // Draw one card for the dealer (face-up)\n        dealer_hand.cards.push(draw_card(deck));\n\n        (*player_hand, *dealer_hand)\n    }\n\n    pub fn player_hit(deck: &mut Deck, player_hand: &mut Hand) -> bool {\n        // Draw a new card\n        player_hand.cards.push(draw_card(deck));\n\n        // Check if player busts\n        check_bust(player_hand)\n    }\n\n    pub fn dealer_play(deck: &mut Deck, dealer_hand: &mut Hand) {\n        // Dealer must hit until the hand value is 17 or more\n        //need to make this a loop without while loop\n        if hand_points(dealer_hand) as u8 < 17 {\n            dealer_hand.cards.push(draw_card(deck));\n        }\n    }\n\n    fn card_points(card: Card) -> Field {\n        if (card.rank as u8 > 1) & (card.rank as u8 <= 10) {\n            card.rank\n        } else if card.rank == 1 {\n            11 // Ace as 11 initially\n        } else {\n            10 //Face cards (J,Q,K)\n        }\n    }\n\n    pub fn determine_winner(player_hand: &mut Hand, dealer_hand: &mut Hand) -> Field {\n        let player_points = hand_points(player_hand) as u8;\n        let dealer_points = hand_points(dealer_hand) as u8;\n\n        let player_bust = check_bust(player_hand);\n        let dealer_bust = check_bust(dealer_hand);\n\n\n        //player wins = 0\n        //dealer wins = 1\n        //push = 2\n        if player_bust {\n            1.to_field()\n        } else if dealer_bust {\n            0.to_field()\n        } else if player_points > dealer_points {\n            0.to_field()\n        } else if dealer_points > player_points {\n            1.to_field()    \n        } else {\n            2.to_field()\n        }\n    }\n\n    \n\n    pub fn hand_points(hand: &mut Hand) -> Field {\n        let mut points = 0;\n        let mut aces = 0;\n\n        // First pass: Calculate initial points and count the number of Aces.\n        for i in 0..hand.cards.len() {\n            let card_point = card_points(hand.cards.get(i));\n            if card_point == Field::from(11) {\n                aces += 1;\n            }\n            points += card_point;\n        }\n\n        // Adjust for Aces if points exceed 21.\n        // Adjust for Aces if points exceed 21.\n        let max_points = 21;\n        if (points as u8 > max_points) & (aces > 0) {\n            points = points - 10;  // Adjust one Ace from 11 to 1\n        }\n        if (points as u8 > max_points) & (aces > 1) {\n        points = points - 10;  // Adjust second Ace if needed\n        }\n        if (points as u8 > max_points) & (aces > 2) {\n            points = points - 10;  // Adjust third Ace if needed\n        }\n\n        // The above conditions effectively handle up to 4 Aces in a hand.\n\n        points\n    }\n\n\n    pub fn check_bust(hand: &mut Hand) -> bool {\n        hand_points(hand) as u8 > 21\n    }\n\n    pub fn generate_deck() -> Deck {\n        let mut deck: Deck = Deck {\n            drawn_cards: BoundedVec::new(),\n        };\n\n        let mut index = 0;\n        for suit in 1..=4 {\n            for rank in 1..=13 {\n                deck.drawn_cards.push(new(rank as Field, suit as Field));\n                index += 1;\n            }\n        }\n        deck\n    }\n\n    fn generate_card() -> Card {\n        // Generate two independent random values\n        // let random_rank = unsafe { random() };\n        // let random_suit = unsafe { random() };\n\n        let random_rank = 3.to_field();\n        let random_suit = 2.to_field();\n        // Use modulo operations to set rank and suit within their respective ranges\n        let rank = (random_rank as u64 % 13) + 1; // rank from 1 to 13\n        let suit = (random_suit as u64 % 4) + 1;   // suit from 1 to 4\n\n        Card { \n            rank: rank as Field, \n            suit: suit as Field \n        }\n    }\n\n}\n\n","path":"/Users/niallcheetham/dev/aztec/blackjack/blackjack/src/CardNote.nr"},"75":{"source":"//functionality that i need:\n\n//make it super simple to start similar to kits\n\n// Player hits/stands to beat dealer's hand by getting as close to 21 as possible.\n\n// Dealer must hit on and up to 16 and stand on 17.\n\n// Player can only double down on 9, 10, or 11.\n\n// Player can either double down or split, player cannot split then double down and vice versa.\n\n// Player cannot split then split again or double down more than once.\n\n// Player who splits Aces can receive only one more additional card on a hand.\n\n// Player can get insurance if dealer might have a BlackJack.\n\n// Aces are high unless card total is already greater than 11.\n\n// Blackjack payout is 3:2.\n\n// No surrender.\n\n//some finds here\n//i had to use my own serialisation and deserialisation for the deck, default ones were not working\n\n\n\nmod CardNote;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\ncontract BlackJack {\n\n    use crate::CardNote::CardNote::{\n        Card, check_bust, Deck, draw_card, generate_deck, Hand, hand_points, new_hand, start_game,\n    };\n    use dep::aztec::{\n        context::PublicContext,\n        macros::{functions::{initializer, private, public, view}, storage::storage},\n        prelude::{AztecAddress, Map, PrivateMutable, PublicImmutable, PublicMutable},\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        card_deck: PublicMutable<Deck, Context>,\n        player_hands: Map<AztecAddress, PublicMutable<Hand, Context>, Context>,\n        dealer_hand: PublicMutable<Hand, Context>,\n    }\n\n    #[private]\n    #[initializer]\n    fn constructor(player: AztecAddress) {\n        // let mut deck = Deck::new(); // Start with an empty deck\n        // storage.card_deck.write(deck);\n    }\n\n    //this is just because the constructor is private\n    #[public]\n    fn initialize_deck() {\n        let mut deck = Deck::new(); // Start with an empty deck\n         storage.card_deck.write(deck);\n    }\n\n\n\n    #[public]\n    #[view]\n    fn dealer_hand() -> Hand {\n        storage.dealer_hand.read()\n    }\n\n    #[public]\n    #[view]\n    fn player_hand(player: AztecAddress) -> Hand {\n        storage.player_hands.at(player).read()\n    }\n\n    #[public]\n    #[view]\n    fn view_deck() -> Deck {\n        storage.card_deck.read()\n    }\n\n    #[public]\n    fn begin_game(player: AztecAddress) {\n        //read existing deck or create a new one\n        let mut deck = if storage.card_deck.read().drawn_cards.len() == 0 {\n            Deck::new()\n            } else {\n                storage.card_deck.read()\n            };\n\n        let mut player_hand = new_hand();\n        let mut dealer_hand = new_hand();\n        start_game(&mut deck, &mut player_hand, &mut dealer_hand);\n\n        //store the deck\n        // storage.card_deck.write(deck);\n\n        //store the hands\n        storage.player_hands.at(player).write(player_hand);\n        storage.dealer_hand.write(dealer_hand);\n    }\n\n\n\n    // #[public]\n    // fn player_hit(player: AztecAddress) {\n    //     let mut deck = storage.card_deck.modify();\n    //     let mut player_hand = storage.player_hands.at(player).modify();\n\n    //     // Draw a new card\n    //     player_hand.cards[player_hand.card_count.to_u32()] = draw_card(deck, deck.drawn_count);\n    //     deck.drawn_count += 1;\n    //     player_hand.card_count += 1;\n\n    //     // Check if player busts\n    //     if check_bust(player_hand) {\n    //         // Handle bust (e.g., end game, declare dealer winner)\n    //         // Implement game over logic here\n    //     }\n\n    //     // Update the player's hand in storage\n    //     storage.player_hands.at(player).write(player_hand);\n    // }\n\n    // #[public]\n    // fn player_stand(player: AztecAddress) {\n    //     // Proceed to dealer's turn\n    //     dealer_play(player);\n    // }\n\n    // #[public]\n    // fn dealer_play(player: AztecAddress) {\n    // let mut deck = storage.card_deck.modify();\n    // let mut dealer_hand = storage.dealer_hand.modify();\n\n    // // Reveal the dealer's hole card\n    // dealer_hand.cards[1] = draw_card(deck, deck.drawn_count);\n    // deck.drawn_count += 1;\n    // dealer_hand.card_count = 2;\n\n    // // Dealer must hit until the hand value is 17 or more\n    // while hand_points(dealer_hand).to_u32() < 17 {\n    //     dealer_hand.cards[dealer_hand.card_count.to_u32()] = draw_card(deck, deck.drawn_count);\n    //     deck.drawn_count += 1;\n    //     dealer_hand.card_count += 1;\n    // }\n\n    // // Update the dealer's hand in storage\n    // storage.dealer_hand.write(dealer_hand);\n\n    // // Determine the outcome\n    // determine_winner(player);\n    // }\n\n    // fn determine_winner(player: AztecAddress) {\n    // let player_hand = storage.player_hands.at(player).read();\n    // let dealer_hand = storage.dealer_hand.read();\n\n    // let player_points = hand_points(player_hand).to_u32();\n    // let dealer_points = hand_points(dealer_hand).to_u32();\n\n    // let player_bust = check_bust(player_hand);\n    // let dealer_bust = check_bust(dealer_hand);\n\n    // let outcome: &str;\n\n    // if player_bust {\n    //     outcome = \"Player busts. Dealer wins.\";\n    // } else if dealer_bust {\n    //     outcome = \"Dealer busts. Player wins!\";\n    // } else if player_points > dealer_points {\n    //     outcome = \"Player wins!\";\n    // } else if dealer_points > player_points {\n    //     outcome = \"Dealer wins.\";\n    // } else {\n    //     outcome = \"Push (tie).\";\n    // }\n\n    // // Handle payouts and game over logic\n    // // Emit event or log outcome\n    // // For simplicity, you can store the outcome in storage or emit it using an event\n    // }\n\n//     #[public]\n//     fn player_double_down(player: AztecAddress) {\n//         let mut deck = storage.card_deck.modify();\n//         let mut player_hand = storage.player_hands.at(player).modify();\n\n//         // Ensure player can only double down on 9, 10, or 11\n//         let player_points = hand_points(player_hand).to_u32();\n//         if player_points < 9 || player_points > 11 {\n//             // Reject the action\n//             // Emit error or revert transaction\n//             return;\n//         }\n\n//         // Double the bet (implement bet logic separately)\n//         // Take exactly one more card\n//         player_hand.cards[player_hand.card_count.to_u32()] = draw_card(deck, deck.drawn_count);\n//         deck.drawn_count += 1;\n//         player_hand.card_count += 1;\n\n//         // Update the player's hand in storage\n//         storage.player_hands.at(player).write(player_hand);\n\n//         // Proceed to dealer's turn\n//         dealer_play(player);\n//     }\n\n//     pub fn hand_points(hand: Hand) -> Field {\n//     let mut points = 0;\n//     let mut aces = 0;\n\n//     for i in 0..hand.card_count.to_u32() {\n//         let card = hand.cards[i];\n//         if card.rank == 1 {\n//             aces += 1;\n//             points += 11; // Assume Ace as 11 initially\n//         } else if card.rank >= 10 {\n//             points += 10;\n//         } else {\n//             points += card.rank;\n//         }\n//     }\n\n//     // Adjust for aces if points exceed 21\n//     while points > 21 && aces > 0 {\n//         points -= 10; // Convert an Ace from 11 to 1\n//         aces -= 1;\n//     }\n\n//     points\n// }\n\n\n\n\n\n\n\n\n}\n","path":"/Users/niallcheetham/dev/aztec/blackjack/blackjack/src/main.nr"},"82":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_header::NoteHeader, note_interface::{NoteInterface, NullifiableNote}},\n};\n\nuse dep::protocol_types::{\n    hash::{\n        compute_siloed_note_hash as compute_siloed_note_hash,\n        compute_siloed_nullifier as compute_siloed_nullifier_from_preimage,\n        compute_unique_note_hash,\n    },\n    utils::arr_copy_slice,\n};\n\npub fn compute_siloed_nullifier<Note, let N: u32>(\n    note_with_header: Note,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note_with_header.get_header();\n    let note_hash_for_nullify = compute_note_hash_for_nullify(note_with_header);\n    let inner_nullifier = note_with_header.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier_from_preimage(header.contract_address, inner_nullifier)\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_read_request<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash = note.compute_note_hash();\n    let nonce = note.get_header().nonce;\n    let counter = note.get_header().note_hash_counter;\n\n    if counter != 0 {\n        note_hash\n    } else {\n        compute_unique_note_hash(nonce, note_hash)\n    }\n}\n\n// TODO(#7775): make this not impossible to understand\npub fn compute_note_hash_for_nullify_internal<Note, let N: u32>(\n    note: Note,\n    note_hash_for_read_request: Field,\n) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let header = note.get_header();\n\n    if header.note_hash_counter != 0 {\n        if header.nonce == 0 {\n            // Case 1: Transient note\n            note_hash_for_read_request\n        } else {\n            // Case 2: Non-revertible note, nullified by a revertible nullifier\n            let unique_note_hash =\n                compute_unique_note_hash(header.nonce, note_hash_for_read_request);\n            compute_siloed_note_hash(header.contract_address, unique_note_hash)\n        }\n    } else {\n        // Case 3: Note from a previous transaction\n        // note_hash_for_read_request is already the unique_note_hash in this case\n        compute_siloed_note_hash(header.contract_address, note_hash_for_read_request)\n    }\n}\n\n// TODO(#7775): nuke this commented out code - kept it around as it contains comments which might be helpful when tackling #7775\n// pub fn compute_note_hash_for_nullify<Note, let N: u32, let M: u32>(note: Note) -> Field where Note: NoteInterface<N> {\n//     let header = note.get_header();\n//     // There are 3 cases for reading a note intended for consumption:\n//     // 1. The note was inserted in this transaction, is revertible, or is not nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce == 0)\n//     // 2. The note was inserted in this transaction, is non-revertible, and is nullified by a revertible nullifier in\n//     //    the same transaction: (note_hash_counter != 0) & (nonce != 0)\n//     // 3. The note was inserted in a previous transaction: (note_hash_counter == 0) & (nonce != 0)\n\n//     let note_hash = note.compute_note_hiding_point().x;\n\n//     if header.nonce == 0 {\n//         // Case 1.\n//         // If a note is transient, we just read the note_hash (kernel will hash it with nonce and silo by contract address).\n//         note_hash\n//     } else {\n//         // Case 2: If a note is non-revertible, and is nullified by a revertible nullifier, we cannot squash them in the\n//         // private reset circuit. Because if the tx reverts, we will have to keep the note hash and throw away the\n//         // nullifier.\n//         // And if the tx does not revert, both will be emitted. In which case, the nullifier must be created in the app\n//         // from the siloed note hash.\n//         // The kernel circuit will check that a nullifier with non-zero note_nonce is linked to a note hash, whose\n//         // siloed note hash matches the note hash specified in the nullifier.\n\n//         // Case 3: If a note is not from the current transaction, that means we are reading a settled note (from\n//         // tree) created in a previous TX. So we need the siloed_note_hash which has already been hashed with\n//         // nonce and then contract address. This hash will match the existing leaf in the note hash\n//         // tree, so the kernel can just perform a membership check directly on this hash/leaf.\n//         let unique_note_hash = compute_unique_note_hash(header.nonce, note_hash);\n//         compute_siloed_note_hash(header.contract_address, unique_note_hash)\n//         // IMPORTANT NOTE ON REDUNDANT SILOING BY CONTRACT ADDRESS: The note hash computed above is\n//         // \"siloed\" by contract address. When a note hash is computed solely for the purpose of\n//         // nullification, it is not strictly necessary to silo the note hash before computing\n//         // its nullifier. In other words, it is NOT NECESSARY for protocol security that a nullifier\n//         // be computed from a siloed note hash. After all, persistable note hashes and nullifiers are\n//         // siloed by the kernel circuit. That being said, the siloed note hash computed above CAN be\n//         // used for nullifier computation, and this achieves the (arguably unnecessary) property that\n//         // nullifiers are computed from a note hash's fully-computed note hash tree leaf.\n//     }\n// }\n\npub fn compute_note_hash_for_nullify<Note, let N: u32>(note: Note) -> Field\nwhere\n    Note: NoteInterface<N> + NullifiableNote,\n{\n    let note_hash_for_read_request = compute_note_hash_for_read_request(note);\n    compute_note_hash_for_nullify_internal(note, note_hash_for_read_request)\n}\n\npub unconstrained fn compute_note_hash_and_optionally_a_nullifier<T, let N: u32, let S: u32>(\n    deserialize_content: fn([Field; N]) -> T,\n    note_header: NoteHeader,\n    compute_nullifier: bool,\n    serialized_note: [Field; S],\n) -> [Field; 4]\nwhere\n    T: NoteInterface<N> + NullifiableNote,\n{\n    let mut note = deserialize_content(arr_copy_slice(serialized_note, [0; N], 0));\n    note.set_header(note_header);\n\n    let note_hash = note.compute_note_hash();\n    let unique_note_hash = compute_unique_note_hash(note_header.nonce, note_hash);\n    let siloed_note_hash = compute_siloed_note_hash(note_header.contract_address, unique_note_hash);\n\n    let inner_nullifier = if compute_nullifier {\n        note.compute_nullifier_without_context()\n    } else {\n        0\n    };\n    // docs:start:compute_note_hash_and_optionally_a_nullifier_returns\n    [note_hash, unique_note_hash, siloed_note_hash, inner_nullifier]\n    // docs:end:compute_note_hash_and_optionally_a_nullifier_returns\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"97":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_FIELD_VALUE, PUBLIC_DISPATCH_SELECTOR};\nuse dep::protocol_types::traits::{Deserialize, Empty, Serialize};\n\npub struct PublicContext {\n    args_hash: Option<Field>,\n    compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_unencrypted_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n        let success = call_static(gas_for_call(gas_opts), contract_address, args);\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(_self: Self) -> AztecAddress {\n        address()\n    }\n    fn msg_sender(_self: Self) -> AztecAddress {\n        sender()\n    }\n    fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        let raw_selector: [Field; 1] = calldata_copy(0, 1);\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    fn transaction_fee(_self: Self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(_self: Self) -> Field {\n        chain_id()\n    }\n    fn version(_self: Self) -> Field {\n        version()\n    }\n    fn block_number(_self: Self) -> Field {\n        block_number()\n    }\n    fn timestamp(_self: Self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(_self: Self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(_self: Self) -> Field {\n        da_gas_left()\n    }\n    fn is_static_call(_self: Self) -> bool {\n        is_static_call() == 1\n    }\n\n    fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            out[i] = storage_read(storage_slot + i as Field);\n        }\n        out\n    }\n\n    fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Deserialize<N>,\n    {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            storage_write(storage_slot + i as Field, values[i]);\n        }\n    }\n\n    fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Serialize<N>,\n    {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\n// TODO(9396): Remove.\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\n// TODO(9396): Remove.\n//unconstrained fn function_selector() -> u32 {\n//    function_selector_opcode()\n//}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_opcode(gas, address, args)\n}\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) -> bool {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\nunconstrained fn avm_return<let N: u32>(returndata: [Field; N]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert<let N: u32>(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n// TODO(9396): Remove.\n//#[oracle(avmOpcodeFunctionSelector)]\n//unconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode<let N: u32>(returndata: [Field; N]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"98":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        arguments,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        header::get_header_at,\n        key_validation_request::get_key_validation_request,\n        logs::{emit_encrypted_event_log, emit_encrypted_note_log},\n        returns::pack_returns,\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        log_hash::{EncryptedLogHash, LogHash, NoteLogHash},\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        MAX_ENCRYPTED_LOGS_PER_CALL, MAX_KEY_VALIDATION_REQUESTS_PER_CALL,\n        MAX_L2_TO_L1_MSGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n        MAX_UNENCRYPTED_LOGS_PER_CALL, PUBLIC_DISPATCH_SELECTOR,\n    },\n    header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::Empty,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_requests: BoundedVec<PublicCallRequest, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_call_request: PublicCallRequest,\n    l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_nullifier(&mut self, nullifier: Field) {\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: self.next_counter(),\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage,\n            note_hashes: self.note_hashes.storage,\n            nullifiers: self.nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_requests: self.public_call_requests.storage,\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator {\n                request,\n                sk_app_generator: sk_generators[key_index],\n            };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<let M: u32>(\n        &mut self,\n        randomness: Field,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<let M: u32>(\n        &mut self,\n        note_hash_counter: u32,\n        log: [u8; M],\n        log_hash: Field,\n    ) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_private_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let (end_side_effect_counter, returns_hash) = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n        );\n\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context,\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        PackedReturns::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.call_public_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        let call_request = PublicCallRequest { call_context, args_hash, counter };\n        self.public_call_requests.push(call_request);\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        arguments::pack_arguments_array(args);\n        self.set_public_teardown_function_with_packed_args(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle repacks the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            counter,\n            is_static_call,\n        );\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n        let call_context = CallContext {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n        };\n\n        self.public_teardown_call_request = PublicCallRequest { call_context, args_hash, counter };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"119":{"source":"use dep::protocol_types::abis::validation_requests::{\n    key_validation_request::KEY_VALIDATION_REQUEST_LENGTH, KeyValidationRequest,\n};\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {}\n\nunconstrained fn get_key_validation_request_internal(\n    npk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    let result = get_key_validation_request_oracle(npk_m_hash, key_index);\n    KeyValidationRequest::deserialize(result)\n}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_internal(pk_m_hash, key_index)\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"124":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"132":{"source":"use dep::protocol_types::{\n    address::AztecAddress, constants::CONTRACT_INSTANCE_LENGTH, contract_class_id::ContractClassId,\n    contract_instance::ContractInstance,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(\n    _address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(\n    address: AztecAddress,\n) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance =\n        unsafe { ContractInstance::deserialize(get_contract_instance_internal(address)) };\n    // The to_address function combines all values in the instance object to produce an address, so by checking that we\n    // get the expected address we validate the entire struct.\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    let (member, exists) = get_contract_instance_deployer_internal_avm(address);\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    let (member, exists) = get_contract_instance_class_id_internal_avm(address);\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    let (member, exists) = get_contract_instance_initialization_hash_internal_avm(address);\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"159":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"160":{"source":"use crate::utils::to_bytes::{arr_to_be_bytes_arr, str_to_be_bytes_arr};\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::Hash,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<let N: u32>(\n    contract_address: AztecAddress,\n    log: [u8; N],\n) -> Field {\n    let mut hash_bytes = [0; N + 36];\n    // Address is converted to 32 bytes in ts\n    let address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let len_bytes: [u8; 4] = (N as Field).to_be_bytes();\n    for i in 0..4 {\n        hash_bytes[32 + i] = len_bytes[i];\n    }\n    for i in 0..N {\n        hash_bytes[36 + i] = log[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd,\n    ];\n    let serialized_log = arr_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0095b2d17ab72f4b27a341f7ac63e49ec73935ae8c9181a0ac02023eb12f3284);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(\n        0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6,\n    );\n    let log = AztecAddress::from_field(\n        0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303,\n    );\n    let serialized_log: [u8; 32] = log.to_field().to_be_bytes();\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0083ab647dfb26e7ddee90a0f4209d049d4660cab42000c544b986aaa84c55a3);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"dummy\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x00629e88ebd6374f44aa6cfe07e251ecf07213ebc7267e8f6b578ae57ffd6c20);\n}\n\n#[test]\nunconstrained fn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(\n        0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8,\n    );\n    let log = \"Hello this is a string\";\n    let serialized_log = str_to_be_bytes_arr(log);\n    let hash = compute_unencrypted_log_hash(contract_address, serialized_log);\n    assert(hash == 0x0098637962f7d34fa202b7ffad8a07a238c5d1fd897b82a108f7f467fa73b841);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"165":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    let (hinted_canonical_public_keys, partial_address) =\n        unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(hinted_canonical_public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    hinted_canonical_public_keys\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"173":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{\n    storage::map::derive_storage_slot_in_map,\n    traits::{Deserialize, Serialize, ToField},\n};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<T, N> for Map<K, T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"181":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<T, N> for PublicMutable<T, Context>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, &mut PublicContext>\nwhere\n    T: Serialize<T_SERIALIZED_LEN> + Deserialize<T_SERIALIZED_LEN>,\n{\n    // docs:start:public_mutable_struct_read\n    pub fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write(self, value: T) {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T, let T_SERIALIZED_LEN: u32> PublicMutable<T, UnconstrainedContext>\nwhere\n    T: Deserialize<T_SERIALIZED_LEN>,\n{\n    pub unconstrained fn read(self) -> T {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"223":{"source":"use crate::{point::Point, traits::{Deserialize, Empty, Serialize}};\npub use crate::constants::KEY_VALIDATION_REQUEST_LENGTH;\n\npub struct KeyValidationRequest {\n    pk_m: Point,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m)) & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest { pk_m: Point::empty(), sk_app: 0 }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [self.pk_m.x, self.pk_m.y, self.pk_m.is_infinite as Field, self.sk_app]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: Point { x: fields[0], y: fields[1], is_infinite: fields[2] as bool },\n            sk_app: fields[3],\n        }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"303":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"305":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn arr_copy_slice<T, let N: u32, let M: u32>(\n    src: [T; N],\n    mut dst: [T; M],\n    offset: u32,\n) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"306":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"312":{"source":"use crate::{\n    address::{\n        aztec_address::AztecAddress, partial_address::PartialAddress,\n        public_keys_hash::PublicKeysHash,\n    },\n    constants::CONTRACT_INSTANCE_LENGTH,\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, Hash, Serialize},\n};\n\npub struct ContractInstance {\n    salt: Field,\n    deployer: AztecAddress,\n    contract_class_id: ContractClassId,\n    initialization_hash: Field,\n    public_keys: PublicKeys,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys.eq(other.public_keys)\n            & self.initialization_hash.eq(other.initialization_hash)\n            & self.contract_class_id.eq(other.contract_class_id)\n            & self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        let public_keys_serialized = self.public_keys.serialize();\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            public_keys_serialized[0],\n            public_keys_serialized[1],\n            public_keys_serialized[2],\n            public_keys_serialized[3],\n            public_keys_serialized[4],\n            public_keys_serialized[5],\n            public_keys_serialized[6],\n            public_keys_serialized[7],\n            public_keys_serialized[8],\n            public_keys_serialized[9],\n            public_keys_serialized[10],\n            public_keys_serialized[11],\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys: PublicKeys::deserialize([\n                serialized[4],\n                serialized[5],\n                serialized[6],\n                serialized[7],\n                serialized[8],\n                serialized[9],\n                serialized[10],\n                serialized[11],\n                serialized[12],\n                serialized[13],\n                serialized[14],\n                serialized[15],\n            ]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"313":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    address::{\n        partial_address::PartialAddress, public_keys_hash::PublicKeysHash,\n        salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        GENERATOR_INDEX__PUBLIC_KEYS_HASH, MAX_FIELD_VALUE,\n    },\n    contract_class_id::ContractClassId,\n    hash::{poseidon2_hash_with_separator, private_functions_root_from_siblings},\n    merkle_tree::membership::MembershipWitness,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n    utils,\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    ec::{pow, sqrt},\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n};\n\n// Aztec address\npub struct AztecAddress {\n    inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secrect can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_private_function(\n        function_selector: FunctionSelector,\n        functino_vk_hash: Field,\n        function_leaf_membership_witness: MembershipWitness<FUNCTION_TREE_HEIGHT>,\n        contract_class_artifact_hash: Field,\n        contract_class_public_bytecode_commitment: Field,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let private_functions_root = private_functions_root_from_siblings(\n            function_selector,\n            functino_vk_hash,\n            function_leaf_membership_witness.leaf_index,\n            function_leaf_membership_witness.sibling_path,\n        );\n\n        let contract_class_id = ContractClassId::compute(\n            contract_class_artifact_hash,\n            private_functions_root,\n            contract_class_public_bytecode_commitment,\n        );\n\n        // Compute contract address using the preimage which includes the class_id.\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"315":{"source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\npub struct SaltedInitializationHash {\n    inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"316":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_ADDRESS_LENGTH: u32 = 1;\n\n// Partial address\npub struct PartialAddress {\n    inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn serialize(self: Self) -> [Field; PARTIAL_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<PARTIAL_ADDRESS_LENGTH> for PartialAddress {\n    fn deserialize(fields: [Field; PARTIAL_ADDRESS_LENGTH]) -> Self {\n        PartialAddress { inner: fields[0] }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"320":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse dep::std::embedded_curve_ops::fixed_base_scalar_mul as derive_public_key;\nuse std::default::Default;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    npk_m: NpkM,\n    ivpk_m: IvpkM,\n    ovpk_m: OvpkM,\n    tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"322":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        log_hash::{LogHash, ScopedEncryptedLogHash, ScopedLogHash},\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, GENERATOR_INDEX__VK,\n        MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    proof::verification_key::VerificationKey,\n    traits::{is_empty, ToField},\n    utils::field::field_from_bytes_32_trunc,\n};\nuse super::utils::field::field_from_bytes;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = std::hash::sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    poseidon2_hash_with_separator(\n        [tx_hash, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    let inputs = [nonce, note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), unique_note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    // We assume contract address has already been masked\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        accumulate_sha256(\n            [log_hash.contract_address.to_field(), log_hash.log_hash.value],\n        )\n    }\n}\n\npub fn mask_encrypted_log_hash(scoped_log: ScopedEncryptedLogHash) -> AztecAddress {\n    if scoped_log.contract_address.is_zero() {\n        AztecAddress::from_field(0)\n    } else if (scoped_log.log_hash.randomness == 0) {\n        scoped_log.contract_address\n    } else {\n        AztecAddress::from_field(poseidon2_hash_with_separator(\n            [scoped_log.contract_address.to_field(), scoped_log.log_hash.randomness],\n            0,\n        ))\n    }\n}\n\nfn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk<let N: u32>(\n    _vk: VerificationKey<N>,\n) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly.\npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        // TODO: This is not checking that the decomposition is smaller than P\n        let input_as_bytes: [u8; 32] = logs[offset].value.to_be_radix(256);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of N + 1\n    let in_len = N + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    // We manually hash the inputs here, since we cannot express with the type system a constant size inputs array of Math.ceil(N/31)\n    let mut in_len = N / 31;\n    let mut has_padding = false;\n    if N % 31 != 0 {\n        in_len += 1;\n        has_padding = true;\n    }\n\n    let two_pow_64 = 18446744073709551616;\n    let iv: Field = (in_len as Field) * two_pow_64;\n    let mut sponge = std::hash::poseidon2::Poseidon2::new(iv);\n\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            sponge.absorb(field_from_bytes(current_field, false));\n            current_field = [0; 31];\n        }\n    }\n    if has_padding {\n        sponge.absorb(field_from_bytes(current_field, false));\n    }\n\n    sponge.squeeze()\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = std::hash::sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"323":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Serialize}};\n\nglobal POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"340":{"source":"use dep::aztec::{\n    context::PrivateContext,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::note,\n    note::{\n        note_header::NoteHeader, note_interface::NullifiableNote,\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress, constants::GENERATOR_INDEX__NOTE_NULLIFIER,\n        hash::poseidon2_hash_with_separator, traits::Serialize,\n    },\n};\n\nglobal VALUE_NOTE_LEN: u32 = 3; // 3 plus a header.\n\n// docs:start:value-note-def\n// ValueNote is used as fn parameter in the Claim contract, so it has to implement the Serialize trait.\n// It is important that the order of these annotations is preserved so that derive(Serialize) runs AFTER the note macro, which injects the note header.\n#[note]\n#[derive(Serialize)]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl NullifiableNote for ValueNote {\n    // docs:start:nullifier\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n\n    // docs:end:nullifier\n\n    unconstrained fn compute_nullifier_without_context(self) -> Field {\n        let note_hash_for_nullify = compute_note_hash_for_nullify(self);\n        let owner_npk_m_hash: Field = get_public_keys(self.owner).npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n        )\n    }\n}\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        // We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        let header = NoteHeader::empty();\n        ValueNote { value, owner, randomness, header }\n    }\n}\n\nimpl Eq for ValueNote {\n    fn eq(self, other: Self) -> bool {\n        (self.value == other.value)\n            & (self.owner == other.owner)\n            & (self.randomness == other.randomness)\n    }\n}\n","path":"/Users/niallcheetham/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.62.0/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}